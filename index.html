<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Explorando a Física Quântica com Carl Sagan - A Sala de Vídeo</title>
    <style>
       
        body { margin: 0; overflow: hidden; cursor: default; background-color: #8B0000;}
        canvas { display: block; }
        .overlay-message { position: fixed; left: 50%; transform: translateX(-50%); color: #ffffff; font-size: 18px; padding: 8px 15px; background: rgba(0,0,0,0.7); border-radius: 8px; display: none; z-index: 200; text-shadow: 1px 1px 2px black; text-align: center; pointer-events: none; }
        #pointerLockMessage { top: 40%; font-size: 24px;}
        #chairInteractionMessage { bottom: 40%; }
        #remoteInteractionMessage { bottom: 35%; }
        #bookshelfInteractionMessage { bottom: 30%; color: #ccddff;}
        #bookshelfOpenMessage { bottom: 30%; color: #ffeecc;}
        #lampInteractionMessage { bottom: 25%; color: #ffffcc;}
        #videoControlMessage { bottom: 20%; color: #ffffaa; }
        #volumeControlMessage { bottom: 15%; color: #aaffaa; }
        #computerInteractionMessage { bottom: 10%; color: #aaaaff; }
        #cameraAcquiredMessage { bottom: 10%; color: #aaffff; font-weight: bold; }
        #cameraPlacementMessage { bottom: 5%; color: #aaffff; }
        #computerZoomMessage { bottom: 5%; color: #ffffaa; }
        #monitorViewMessage { top: 10%; color: #ddddff; font-size: 20px; }
        #breakerInteractionMessage { bottom: 1%; color: #ffdddd; }
        #socketInteractionMessage { bottom: 1%; color: #ccffff; }
        #powerStatusMessage { top: 5%; left: 10px; transform: none; text-align: left; color: #ffccaa; }
        #flashlightStatusMessage { top: 8%; left: 10px; transform: none; text-align: left; color: #ccffcc; }
        #rechargeMessage { top: 50%; font-size: 22px; color: #ffff99; background: rgba(50,50,0,0.8); }
        #flashlightRechargeMessage { top: 55%; font-size: 20px; color: #ccffff; background: rgba(0,50,50,0.8); }

        #bookContentDisplay { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 70%; max-width: 600px; max-height: 75%; overflow-y: auto; background: rgba(20, 10, 0, 0.92); color: #fff; padding: 30px; padding-top: 45px; border: 2px solid #a0522d; border-radius: 10px; z-index: 400; font-family: sans-serif; text-align: left; box-shadow: 0 0 25px rgba(0,0,0,0.8); cursor: default; scrollbar-width: thin; scrollbar-color: #a0522d rgba(20, 10, 0, 0.92); }
        #bookContentDisplay::-webkit-scrollbar { width: 8px; }
        #bookContentDisplay::-webkit-scrollbar-track { background: rgba(20, 10, 0, 0.92); }
        #bookContentDisplay::-webkit-scrollbar-thumb { background-color: #a0522d; border-radius: 4px; border: 2px solid rgba(20, 10, 0, 0.92); }
        #bookContentText { white-space: pre-wrap; line-height: 1.7; margin-top: 15px; font-size: 16px; }
        #closeBookBtn { position: absolute; top: 10px; right: 10px; background: #8B0000; color: white; border: 1px solid white; border-radius: 50%; width: 30px; height: 30px; font-weight: bold; font-size: 16px; cursor: pointer; line-height: 28px; text-align: center; transition: background-color 0.2s ease, transform 0.1s ease; }
         #closeBookBtn:hover { background-color: #a00000; transform: scale(1.1); }
         #closeBookBtn:active { transform: scale(1.0); }
        #configPanel { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(50, 0, 0, 0.9); color: white; padding: 25px; border-radius: 10px; border: 1px solid rgba(255, 100, 100, 0.4); z-index: 300; display: none; font-family: sans-serif; min-width: 280px; box-shadow: 0 4px 15px rgba(0,0,0,0.5); text-align: left; }
        #configPanel h2 { margin-top: 0; margin-bottom: 20px; text-align: center; font-size: 1.5em; border-bottom: 1px solid rgba(255, 100, 100, 0.3); padding-bottom: 10px; }
        #configPanel div { margin-bottom: 15px; display: flex; align-items: center; justify-content: space-between; }
        #configPanel label { margin-right: 10px; flex-shrink: 0; }
        #configPanel input[type="checkbox"] { width: 20px; height: 20px; cursor: pointer; }
        #configPanel input[type="range"] { flex-grow: 1; cursor: pointer; margin-left: 10px; }
        #configPanel #sensitivityValueSpan { margin-left: 10px; min-width: 40px; text-align: right; font-family: monospace; }
        #configPanel button { display: block; width: 100%; padding: 10px; margin-top: 15px; background-color: #6a0000; border: 1px solid #a00000; color: white; border-radius: 5px; cursor: pointer; font-size: 1em; transition: background-color 0.2s ease; }
        #configPanel button:hover { background-color: #8a0000; }
        .hud { position: fixed; color: rgba(255, 200, 200, 0.8); font-family: monospace; font-size: 18px; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8); pointer-events: none; z-index: 150; display: none; }
        #hud-crosshair { top: 50%; left: 50%; transform: translate(-50%, -50%); width: 10px; height: 10px; background-color: rgba(255, 255, 255, 0); border: 1px solid rgba(255, 200, 200, 0.7); border-radius: 50%; }
        #hud-speed { bottom: 10px; left: 20px; }
        .mobile-buttons { display: none; }
        @media (max-width: 768px) { .mobile-buttons { display: block; position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 100; text-align: center; } .mobile-buttons button { width: 60px; height: 60px; margin: 5px; font-size: 24px; background: rgba(255, 100, 100, 0.2); border: 1px solid rgba(255, 150, 150, 0.5); color: white; border-radius: 50%; } }
    </style>
</head>
<body>
    <div id="pointerLockMessage" class="overlay-message">Cursor Liberado<br>Clique na área para retomar</div>
    <div id="chairInteractionMessage" class="overlay-message"></div>
    <div id="remoteInteractionMessage" class="overlay-message"></div>
    <div id="bookshelfInteractionMessage" class="overlay-message">Pressione [U] para ver a estante</div>
    <div id="bookshelfOpenMessage" class="overlay-message">Estante: [1] [2] [3] Selecionar | [U] Fechar</div>
    <div id="lampInteractionMessage" class="overlay-message"></div>
    <div id="videoControlMessage" class="overlay-message"></div>
    <div id="volumeControlMessage" class="overlay-message">Volume: 50%</div>
    <div id="computerInteractionMessage" class="overlay-message"></div>
    <div id="cameraAcquiredMessage" class="overlay-message"></div>
    <div id="cameraPlacementMessage" class="overlay-message"></div>
    <div id="computerZoomMessage" class="overlay-message"></div>
    <div id="monitorViewMessage" class="overlay-message"></div>
    <div id="breakerInteractionMessage" class="overlay-message"></div>
    <div id="socketInteractionMessage" class="overlay-message"></div>
    <div id="powerStatusMessage" class="overlay-message"></div>
    <div id="flashlightStatusMessage" class="overlay-message"></div>
    <div id="rechargeMessage" class="overlay-message"></div>
    <div id="flashlightRechargeMessage" class="overlay-message"></div>
    <div id="bookContentDisplay"><button id="closeBookBtn" title="Fechar Livro (U ou ESC)">X</button><p id="bookContentText"></p></div>
    <div id="hud-crosshair" class="hud"></div>
    <div id="hud-speed" class="hud">Velocidade: 0.00</div>
    <div id="configPanel"><h2>Configurações</h2><div> <label for="pitchLimitCheckbox">Limitar Câmera Vertical:</label> <input type="checkbox" id="pitchLimitCheckbox"> </div><div> <label for="sensitivitySlider">Sensibilidade:</label> <input type="range" id="sensitivitySlider" min="0.0005" max="0.005" step="0.0001"> <span id="sensitivityValueSpan">0.0020</span> </div><button id="closeConfigBtn">Fechar</button></div>
    <div class="mobile-buttons"> <div><button id="btn-up">↑</button></div> <div> <button id="btn-left">←</button> <button id="btn-down">↓</button> <button id="btn-right">→</button> </div> </div>
    <video id="saganVideo" loop muted playsinline style="display:none" src="textures/quarta1.mp4" crossorigin="anonymous"></video>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>
    <script>
        const DEFAULT_SENSITIVITY = 0.002; const DEFAULT_PITCH_LIMIT_ENABLED = true;
        const acceleration = 0.008; const damping = 0.94; const maxSpeed = 0.24;
        const PLAYER_EYE_HEIGHT = 1.6; const PLAYER_RADIUS = 0.3;
        const GRAVITY_STRENGTH = 0.015;
        const NUM_BLOCKS = 10; const BLOCK_SIZE = 2.0; const BLOCK_SPREAD_RANGE = 150; const BLOCK_MIN_DISTANCE = 40; const BLOCK_BASE_COLOR = 0xff6347; const BLOCK_EMISSIVE_COLOR = 0x8B0000; const BLOCK_EMISSIVE_INTENSITY = 0.3; const BLOCK_TEXT_COLOR = 0xffffff; const BLOCK_TEXT_SIZE = 0.3; const BLOCK_TEXT_HEIGHT = 0.02; const BLOCK_TEXT_OFFSET_Y = BLOCK_SIZE * 0.7; const BLOCK_MOVE_SPEED_FACTOR = 0.05; const BLOCK_ROTATE_SPEED_FACTOR = 0.005;
        const BLOCK_PLACEHOLDER_TEXTS = ["Dualidade Onda-Partícula...", "Princípio da Incerteza...", "Superposição Quântica...", "Emaranhamento Quântico...", "Salto Quântico...", "Efeito Túnel...", "Gato de Schrödinger...", "Computação Quântica...", "Interpretação de Copenhague...", "Interpretação de Muitos Mundos..."];
        const HOUSE_WIDTH = 15; const HOUSE_HEIGHT = 6; const HOUSE_DEPTH = 12; const HOUSE_POSITION = new THREE.Vector3(0, HOUSE_HEIGHT / 2, -30); const WALL_THICKNESS = 0.5;
        const HOUSE_FLOOR_Y_OFFSET = (-HOUSE_HEIGHT / 2) + (WALL_THICKNESS / 2);
        const DOOR_WIDTH = 1.5; const DOOR_HEIGHT = 2.2; const DOOR_FRAME_THICKNESS = 0.05;
        const TEXTURE_PATH = 'textures/'; const WALL_TEXTURE_FILE = TEXTURE_PATH + 'wall_texture.webp'; const FLOOR_TEXTURE_FILE = TEXTURE_PATH + 'floor_texture.webp'; const ROOF_TEXTURE_FILE = TEXTURE_PATH + 'roof_texture.webp'; const PATH_TEXTURE_FILE = TEXTURE_PATH + 'estrada.png';
        const WALL_TEXTURE_REPEAT_X = 5; const WALL_TEXTURE_REPEAT_Y = 2; const FLOOR_TEXTURE_REPEAT_X = 4; const FLOOR_TEXTURE_REPEAT_Z = 3; const ROOF_TEXTURE_REPEAT_X = 4; const ROOF_TEXTURE_REPEAT_Z = 3; const PATH_TEXTURE_REPEAT_X = 1; const PATH_TEXTURE_REPEAT_Z = 5;
        const PATH_WIDTH = DOOR_WIDTH * 1.5; const PATH_LENGTH = 15.0; const PATH_THICKNESS = 0.1;
        const PATH_Y_OFFSET = HOUSE_FLOOR_Y_OFFSET - PATH_THICKNESS / 2;
        const CHAIR_POSITION_INSIDE_HOUSE = new THREE.Vector3( 0, HOUSE_FLOOR_Y_OFFSET + 0.8 + 0.01, HOUSE_DEPTH / 2 - 3 );
        const CHAIR_INTERACTION_RANGE = 2.5;
        const VIDEO_SCREEN_POSITION_INSIDE_HOUSE = new THREE.Vector3(0, 0, -HOUSE_DEPTH / 2 + WALL_THICKNESS + 0.1);
        const VIDEO_SCREEN_WIDTH = HOUSE_WIDTH * 0.6; const VIDEO_SCREEN_HEIGHT = VIDEO_SCREEN_WIDTH * (9 / 16);
        const REMOTE_POSITION_INSIDE_HOUSE = new THREE.Vector3(1.5, HOUSE_FLOOR_Y_OFFSET + 0.5, HOUSE_DEPTH / 2 - 3.5);
        const REMOTE_SIZE = { width: 0.15, height: 0.4, depth: 0.05 }; const REMOTE_TEXTURE_FILE = TEXTURE_PATH + 'controle1.jpg'; const REMOTE_INTERACTION_RANGE = 1.8;
        const BOOKSHELF_INTERACTION_RANGE = 3.5;
        const TABLE_POSITION_INSIDE_HOUSE_X = 0; const TABLE_POSITION_INSIDE_HOUSE_Y = HOUSE_FLOOR_Y_OFFSET; const TABLE_POSITION_INSIDE_HOUSE_Z = CHAIR_POSITION_INSIDE_HOUSE.z - 2.0;
        const TABLE_WIDTH = 1.5; const TABLE_DEPTH = 0.8; const TABLE_HEIGHT = 0.7;
        const LAMP_INTERACTION_RANGE = 1.5; const DEFAULT_LAMP_INTENSITY = 3.5; const LAMP_LIGHT_DISTANCE = 8.0; const LAMP_LIGHT_DECAY = 1.5; const LAMP_LIGHT_COLOR = 0xfff0d1;
        const COMPUTER_INTERACTION_RANGE = 1.8;
        const CAMERA_PLACE_MAX_DISTANCE = 8.0;
        const CAMERA_RENDER_TARGET_WIDTH = 512; const CAMERA_RENDER_TARGET_HEIGHT = 512;
        const CAMERA_FOV_NORMAL = 60;
        const CAMERA_FOV_ZOOM = 30;
        const MAX_CAMERAS = 3;
        const CAMERA_COLORS = [0x00ff00, 0x0088ff, 0xff4444];
        const BUY_CAMERA_KEY = 'h';
        const PLACE_CAMERA_KEY = 'b';
        const ZOOM_KEY = 'z';
        const SWITCH_VIEW_KEY = 'c';
        const MAX_ENERGY = 100.0;
        const ENERGY_DRAIN_BASE_PER_SEC = 0.0;
        const ENERGY_DRAIN_LAMP_INTERNAL_PER_SEC = 0.5;
        const ENERGY_DRAIN_LAMP_EXTERNAL_PER_SEC = 0.3;
        const ENERGY_DRAIN_CAMERA_PER_SEC = 1.0;
        const POWER_OUTAGE_THRESHOLD = 0.1;
        const BREAKER_INTERACTION_RANGE = 1.5;
        const RECHARGE_KEY = 'm';
        const RECHARGE_DURATION = 5.0;
        const SOCKET_INTERACTION_RANGE = 1.5;
        const FLASHLIGHT_RECHARGE_KEY = 'r';
        const FLASHLIGHT_RECHARGE_RATE_PER_SEC = 25.0;
        const FLASHLIGHT_TOGGLE_KEY = 'n';
        const FLASHLIGHT_MAX_ENERGY = 100.0;
        const FLASHLIGHT_DRAIN_PER_SEC = 1.0;
        const FLASHLIGHT_COLOR = 0xffffdd;
        const FLASHLIGHT_INTENSITY = 0.3;
        const FLASHLIGHT_DISTANCE = 25.0;
        const FLASHLIGHT_ANGLE = Math.PI / 3;
        const FLASHLIGHT_PENUMBRA = 0.3;
        const FLASHLIGHT_DECAY = 1.0;
        const EXTERIOR_LAMP_COLOR = 0xffdcb8; const EXTERIOR_LAMP_INTENSITY = 2.0; const EXTERIOR_LAMP_DISTANCE = 15.0; const EXTERIOR_LAMP_ANGLE = Math.PI / 3.5; const EXTERIOR_LAMP_PENUMBRA = 0.3; const EXTERIOR_LAMP_DECAY = 1.8;
        const INITIAL_AMBIENT_INTENSITY = 0.05; const INITIAL_AMBIENT_COLOR = 0x201005;
        const POWER_OUT_AMBIENT_INTENSITY = 0.01;
        const BACKGROUND_MUSIC_FILE = 'textures/quarta.mp3';
        const INITIAL_VOLUME = 0.5; const VOLUME_STEP = 0.1; const AUDIO_REF_DISTANCE = 3.0; const AUDIO_ROLLOFF_FACTOR = 2.0; const AUDIO_MAX_DISTANCE = 16.0;
        const SIT_KEY = 'e'; const GRAB_REMOTE_KEY = 'g'; const VIDEO_PAUSE_KEY = 'p'; const VIDEO_START_KEY = 't';
        const VOLUME_UP_KEY = 'l'; const VOLUME_DOWN_KEY = 'k';
        const BOOKSHELF_INTERACT_KEY = 'u'; const LAMP_TOGGLE_KEY = 'f';
        const BOOK_SELECT_KEYS = ['1', '2', '3'];
        const STARFIELD1_COUNT = 60000; const STARFIELD1_SIZE = 1.8; const STARFIELD1_COLOR = 0xff6666; const STARFIELD2_COUNT = 50000; const STARFIELD2_SIZE = 1.2; const STARFIELD2_COLOR = 0xffaaaa;

        var scene, camera, renderer, listener; var ambientLight;
        var menuGroup, playTextMesh, configTextMesh; var starField1, starField2; var physicsBlocksGroup; var blockData = []; var mainFont = null; var textureLoader = null; var houseGroup = null; var chairMesh = null; var videoScreenMesh = null; var saganVideoElement = null; var saganVideoTexture = null; var remoteMesh = null; var backgroundMusic = null;
        var keys = {}; var velocity = new THREE.Vector3(0, 0, 0); var raycaster = new THREE.Raycaster(); var mouse = new THREE.Vector2(); var gameStarted = false; var isTransitioning = false; var freezePlayer = false; var isPitchLimitEnabled = DEFAULT_PITCH_LIMIT_ENABLED; var mouseSensitivity = DEFAULT_SENSITIVITY;
        var clock = new THREE.Clock();
        var isSitting = false; var isTransitioningCamera = false; var targetCameraPos = new THREE.Vector3(); var targetCameraLookAt = new THREE.Vector3(); var originalCameraPos = new THREE.Vector3(); var originalCameraQuat = new THREE.Quaternion();
        var hasRemoteControl = false;
        var bookContents = ["Eu sou Carl Sagan. Eu amava física, mas acabei descobrindo algo que não podia descobrir. Você foi enviado para cuidar de um experimento. Cuidado, podem aparecer algumas coisas por aí, mas nada vai te matar. Deixei uma tomada e uma lanterna para você (aperte N para usá-la). Caso a energia caia, você terá que ligar o disjuntor aí perto da porta (aperte M perto dele), viu? Sabe como é? Foi bem caro colocar você aí. De qualquer forma, veja o que você consegue fazer. Veja as câmeras apertando H para poder comprar mais câmeras. Você pode posicioná-las apertando B. Aperte Z para dar zoom no monitor. Pegue o controle e veja meus vídeos. Pode te animar um pouco. Cuidado com qualquer coisa aí...Ah, esqueci: você também pode mudar as câmeras no monitor apertando C. Bem, acho que era isso. O resto, só você descobrindo.", "Criei este jogo sem muita expectativa; ele foi feito em 5 dias. Eu queria fazer algo interessante, e foi isto que saiu. Fiz tudo sozinha, sem IA (Inteligência Artificial) ou algo do gênero. Ele tem algumas coisas divertidas, mas, de fato, está faltando muito mais do que eu queria colocar. A ideia completa seria muito mais complexa. Para um protótipo, creio que sirva. De qualquer forma, aproveite o que tem aí!", "Créditos. Em memória de Carl Sagan. Obrigada à NASA pela série 'Cosmos'. Agradecimento pela inspiração sobre a quarta dimensão ([https://www.youtube.com/watch?v=LfixKmCwuKg&t=28s] - por favor, dê um 'like' lá!). Todo o resto foi feito por mim."];
        var isNearBookshelf = false; var isBookshelfInteractionOpen = false; var selectedBookIndex = -1; var isInBookView = false; var preBookViewPos = new THREE.Vector3(); var preBookViewQuat = new THREE.Quaternion();
        var isNearLampButton = false;
        var isNearComputer = false;
        var numCamerasOwned = 0;
        var numCamerasPlaced = 0;
        var placeableMeshes = [];
        var placedCameraObjects = [];
        var placedCameraMeshes = [];
        var currentMonitorViewIndex = 0;
        var cameraRenderTarget = null;
        var isZoomedToComputer = false;
        var isTransitioningZoom = false;
        var preZoomPos = new THREE.Vector3();
        var preZoomQuat = new THREE.Quaternion();
        var targetZoomPos = new THREE.Vector3();
        var targetZoomLookAt = new THREE.Vector3();
        var originalFov = CAMERA_FOV_NORMAL;
        var isInGravityZone = false; var houseMinBounds = new THREE.Vector3(); var houseMaxBounds = new THREE.Vector3();
        var pathMesh = null; var pathMinBounds = new THREE.Vector3(); var pathMaxBounds = new THREE.Vector3();
        var collidableMeshes = []; var worldFloorY = 0;
        var lampGroup = null; var lampLight = null; var lampButtonMesh = null; var isLampOn = false;
        var exteriorLamp = null;
        var tableGroup = null; var cubelandiaCubeMesh = null; var appleGroup = null;
        var computerMonitorMesh = null; var computerScreenMaterial = null;
        var circuitBreakerMesh = null;
        var flashlight = null;
        var flashlightHelper = null;
        var wallSocketMesh = null;
        var currentEnergy = MAX_ENERGY;
        var isPowerOut = false;
        var wasLampOnBeforeOutage = false;
        var wasVideoPlayingBeforeOutage = false;
        var videoVolumeBeforeOutage = INITIAL_VOLUME;
        var isNearBreaker = false;
        var isRecharging = false;
        var rechargeTimer = 0;
        var flashlightEnergy = FLASHLIGHT_MAX_ENERGY;
        var isFlashlightOn = false;
        var isNearSocket = false;
        var isRechargingFlashlight = false;

        const _vector = new THREE.Vector3();
        const _worldBox = new THREE.Box3();
        const _playerBox = new THREE.Box3();
        const _placementRay = new THREE.Raycaster();
        const _worldQuaternion = new THREE.Quaternion();

        const pointerLockDiv = document.getElementById("pointerLockMessage"); const configPanel = document.getElementById("configPanel"); const pitchLimitCheckbox = document.getElementById("pitchLimitCheckbox"); const sensitivitySlider = document.getElementById("sensitivitySlider"); const sensitivityValueSpan = document.getElementById("sensitivityValueSpan"); const closeConfigBtn = document.getElementById("closeConfigBtn"); const hudCrosshair = document.getElementById("hud-crosshair"); const hudSpeed = document.getElementById("hud-speed"); const chairInteractionDiv = document.getElementById("chairInteractionMessage");
        var remoteInteractionMessageDiv = null;
        const videoControlDiv = document.getElementById("videoControlMessage"); const volumeControlDiv = document.getElementById("volumeControlMessage");
        var bookshelfInteractionMessageDiv = null; var bookshelfOpenMessageDiv = null; var bookContentDisplayDiv = null; var bookContentTextElement = null; var lampInteractionMessageDiv = null;
        var computerInteractionMessageDiv = null; var cameraAcquiredMessageDiv = null; var cameraPlacementMessageDiv = null; var computerZoomMessageDiv = null; var monitorViewMessageDiv = null;
        var breakerInteractionMessageDiv = null; var powerStatusMessageDiv = null; var flashlightStatusMessageDiv = null; var rechargeMessageDiv = null;
        var socketInteractionMessageDiv = null;
        var flashlightRechargeMessageDiv = null;

        function init() {
            saganVideoElement = document.getElementById('saganVideo');
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(CAMERA_FOV_NORMAL, window.innerWidth / window.innerHeight, 0.1, 3000);
            camera.position.set(0, PLAYER_EYE_HEIGHT, 10);
            camera.rotation.order = 'YXZ';
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            listener = new THREE.AudioListener();
            camera.add(listener);
            ambientLight = new THREE.AmbientLight(INITIAL_AMBIENT_COLOR, INITIAL_AMBIENT_INTENSITY);
            scene.add(ambientLight);
            console.log("Iluminação inicial configurada.");
            textureLoader = new THREE.TextureLoader();
            var fontLoader = new THREE.FontLoader();
            fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (font) {
                mainFont = font; console.log("Fonte carregada."); createMenu();
            }, undefined, (err) => { console.error("Erro fonte:", err); alert("Erro ao carregar recursos essenciais."); });
            bookshelfInteractionMessageDiv = document.getElementById("bookshelfInteractionMessage");
            bookshelfOpenMessageDiv = document.getElementById("bookshelfOpenMessage");
            bookContentDisplayDiv = document.getElementById("bookContentDisplay");
            bookContentTextElement = document.getElementById("bookContentText");
            lampInteractionMessageDiv = document.getElementById("lampInteractionMessage");
            computerInteractionMessageDiv = document.getElementById("computerInteractionMessage");
            cameraAcquiredMessageDiv = document.getElementById("cameraAcquiredMessage");
            cameraPlacementMessageDiv = document.getElementById("cameraPlacementMessage");
            computerZoomMessageDiv = document.getElementById("computerZoomMessage");
            monitorViewMessageDiv = document.getElementById("monitorViewMessage");
            breakerInteractionMessageDiv = document.getElementById("breakerInteractionMessage");
            powerStatusMessageDiv = document.getElementById("powerStatusMessage");
            flashlightStatusMessageDiv = document.getElementById("flashlightStatusMessage");
            rechargeMessageDiv = document.getElementById("rechargeMessage");
            socketInteractionMessageDiv = document.getElementById("socketInteractionMessage");
            flashlightRechargeMessageDiv = document.getElementById("flashlightRechargeMessage");
            remoteInteractionMessageDiv = document.getElementById("remoteInteractionMessage");
            const closeBookBtn = document.getElementById("closeBookBtn");
            if(closeBookBtn) closeBookBtn.addEventListener('click', closeBook);
            createStarfields();
            setupEventListeners();
            setupConfigPanel();
            animate();
        }

        function createStarfields() { var starsGeometry1=new THREE.BufferGeometry();var starsGeometry2=new THREE.BufferGeometry();var starVertices1=[];var starVertices2=[];for(let i=0;i<STARFIELD1_COUNT;i++){starVertices1.push(THREE.MathUtils.randFloatSpread(2500),THREE.MathUtils.randFloatSpread(2500),THREE.MathUtils.randFloatSpread(2500));}starsGeometry1.setAttribute('position',new THREE.Float32BufferAttribute(starVertices1,3));var starsMaterial1=new THREE.PointsMaterial({color:STARFIELD1_COLOR,size:STARFIELD1_SIZE,sizeAttenuation:true});starField1=new THREE.Points(starsGeometry1,starsMaterial1);scene.add(starField1);for(let i=0;i<STARFIELD2_COUNT;i++){starVertices2.push(THREE.MathUtils.randFloatSpread(2500),THREE.MathUtils.randFloatSpread(2500),THREE.MathUtils.randFloatSpread(2500));}starsGeometry2.setAttribute('position',new THREE.Float32BufferAttribute(starVertices2,3));var starsMaterial2=new THREE.PointsMaterial({color:STARFIELD2_COLOR,size:STARFIELD2_SIZE,sizeAttenuation:true});starField2=new THREE.Points(starsGeometry2,starsMaterial2);scene.add(starField2); }
        function createMenu() { if (!mainFont) { console.error("Fonte não carregada, impossível criar menu."); return; } menuGroup = new THREE.Group(); scene.add(menuGroup); const menuLight = new THREE.PointLight(0xffcccc, 1.5, 30); menuLight.position.set(0, 1, 10); menuGroup.add(menuLight); const commonMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, emissive: 0xffdddd, emissiveIntensity: 1.2, roughness: 0.3, metalness: 0.8 }); const textOptionsPlay = { font: mainFont, size: 1, height: 0.2, curveSegments: 12, bevelEnabled: true, bevelThickness: 0.05, bevelSize: 0.03, bevelSegments: 3 }; var playTextGeometry = new THREE.TextGeometry('Explorar!', textOptionsPlay); playTextGeometry.computeBoundingBox(); var centerOffsetPlay = -0.5 * (playTextGeometry.boundingBox.max.x - playTextGeometry.boundingBox.min.x); playTextMesh = new THREE.Mesh(playTextGeometry, commonMaterial.clone()); playTextMesh.position.set(centerOffsetPlay, 1, 0); menuGroup.add(playTextMesh); const textOptionsConfig = { font: mainFont, size: 0.6, height: 0.1, curveSegments: 12, bevelEnabled: true, bevelThickness: 0.03, bevelSize: 0.02, bevelSegments: 3 }; var configTextGeometry = new THREE.TextGeometry('Config', textOptionsConfig); configTextGeometry.computeBoundingBox(); var centerOffsetConfig = -0.5 * (configTextGeometry.boundingBox.max.x - configTextGeometry.boundingBox.min.x); configTextMesh = new THREE.Mesh(configTextGeometry, commonMaterial.clone()); configTextMesh.position.set(centerOffsetConfig, -0.5, 0); menuGroup.add(configTextMesh); console.log("Menu criado."); }
        function createPhysicsBlocks() { if (!mainFont) { console.error("Fonte não carregada."); return; } physicsBlocksGroup = new THREE.Group(); scene.add(physicsBlocksGroup); blockData = []; const blockGeometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE); const blockMaterial = new THREE.MeshStandardMaterial({ color: BLOCK_BASE_COLOR, emissive: BLOCK_EMISSIVE_COLOR, emissiveIntensity: BLOCK_EMISSIVE_INTENSITY, roughness: 0.6, metalness: 0.2 }); const textMaterial = new THREE.MeshBasicMaterial({ color: BLOCK_TEXT_COLOR, side: THREE.DoubleSide }); const textOptions = { font: mainFont, size: BLOCK_TEXT_SIZE, height: BLOCK_TEXT_HEIGHT, curveSegments: 4, bevelEnabled: false }; const minRangeSq = BLOCK_MIN_DISTANCE * BLOCK_MIN_DISTANCE; for (let i = 0; i < NUM_BLOCKS; i++) { const blockMesh = new THREE.Mesh(blockGeometry, blockMaterial); let x, y, z, distSq; do { x = THREE.MathUtils.randFloatSpread(BLOCK_SPREAD_RANGE * 2); y = THREE.MathUtils.randFloatSpread(BLOCK_SPREAD_RANGE * 2); z = THREE.MathUtils.randFloatSpread(BLOCK_SPREAD_RANGE * 2); distSq = x * x + y * y + z * z; } while (distSq < minRangeSq); blockMesh.position.set(x, y, z); blockMesh.rotation.set(Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, Math.random() * Math.PI * 2); blockMesh.userData.velocity = new THREE.Vector3( (Math.random() - 0.5) * BLOCK_MOVE_SPEED_FACTOR, (Math.random() - 0.5) * BLOCK_MOVE_SPEED_FACTOR, (Math.random() - 0.5) * BLOCK_MOVE_SPEED_FACTOR ); blockMesh.userData.angularVelocity = new THREE.Vector3( (Math.random() - 0.5) * BLOCK_ROTATE_SPEED_FACTOR, (Math.random() - 0.5) * BLOCK_ROTATE_SPEED_FACTOR, (Math.random() - 0.5) * BLOCK_ROTATE_SPEED_FACTOR ); physicsBlocksGroup.add(blockMesh); const placeholder = BLOCK_PLACEHOLDER_TEXTS[i % BLOCK_PLACEHOLDER_TEXTS.length] || `Conceito ${i + 1}`; const textGeometry = new THREE.TextGeometry(placeholder, textOptions); textGeometry.computeBoundingBox(); const centerOffsetX = -0.5 * (textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x); const centerOffsetY = -0.5 * (textGeometry.boundingBox.max.y - textGeometry.boundingBox.min.y); const textMesh = new THREE.Mesh(textGeometry, textMaterial); textMesh.position.set(centerOffsetX, BLOCK_TEXT_OFFSET_Y + centerOffsetY, BLOCK_SIZE / 2 + 0.1); blockMesh.add(textMesh); blockData.push({ block: blockMesh, text: textMesh }); } }
        function createHouse() { console.log("Criando casa com porta..."); collidableMeshes = []; placeableMeshes = []; houseGroup = new THREE.Group(); houseGroup.position.copy(HOUSE_POSITION); houseMinBounds.copy(HOUSE_POSITION).sub(new THREE.Vector3(HOUSE_WIDTH / 2, HOUSE_HEIGHT / 2, HOUSE_DEPTH / 2)); houseMaxBounds.copy(HOUSE_POSITION).add(new THREE.Vector3(HOUSE_WIDTH / 2, HOUSE_HEIGHT / 2, HOUSE_DEPTH / 2)); const wallMaterial = new THREE.MeshStandardMaterial({ roughness: 0.8, metalness: 0.1 }); const floorMaterial = new THREE.MeshStandardMaterial({ roughness: 0.7, metalness: 0.1 }); const roofMaterial = new THREE.MeshStandardMaterial({ roughness: 0.9, metalness: 0.05 }); textureLoader.load(WALL_TEXTURE_FILE, (t) => { t.wrapS=t.wrapT=THREE.RepeatWrapping; t.repeat.set(WALL_TEXTURE_REPEAT_X,WALL_TEXTURE_REPEAT_Y); wallMaterial.map=t; wallMaterial.needsUpdate=true; }, undefined, (e)=>{console.error('Erro Tex Parede'); wallMaterial.color.set(0xaaaaaa);}); textureLoader.load(FLOOR_TEXTURE_FILE, (t) => { t.wrapS=t.wrapT=THREE.RepeatWrapping; t.repeat.set(FLOOR_TEXTURE_REPEAT_X,FLOOR_TEXTURE_REPEAT_Z); floorMaterial.map=t; floorMaterial.needsUpdate=true; }, undefined,(e)=>{console.error('Erro Tex Chão'); floorMaterial.color.set(0x888888);}); textureLoader.load(ROOF_TEXTURE_FILE, (t) => { t.wrapS=t.wrapT=THREE.RepeatWrapping; t.repeat.set(ROOF_TEXTURE_REPEAT_X,ROOF_TEXTURE_REPEAT_Z); roofMaterial.map=t; roofMaterial.needsUpdate=true; }, undefined, (e)=>{console.error('Erro Tex Teto'); roofMaterial.color.set(0x777777);}); const floorGeometry = new THREE.BoxGeometry(HOUSE_WIDTH, WALL_THICKNESS, HOUSE_DEPTH); const floorMesh = new THREE.Mesh(floorGeometry, floorMaterial); floorMesh.position.y = -HOUSE_HEIGHT / 2; floorMesh.receiveShadow = true; floorMesh.userData.isGround = true; floorMesh.userData.isPlaceable = true; houseGroup.add(floorMesh); collidableMeshes.push(floorMesh); placeableMeshes.push(floorMesh); const roofGeometry = new THREE.BoxGeometry(HOUSE_WIDTH, WALL_THICKNESS, HOUSE_DEPTH); const roofMesh = new THREE.Mesh(roofGeometry, roofMaterial); roofMesh.position.y = HOUSE_HEIGHT / 2; roofMesh.castShadow = true; roofMesh.receiveShadow = true; houseGroup.add(roofMesh); collidableMeshes.push(roofMesh); const wallBackGeometry = new THREE.BoxGeometry(HOUSE_WIDTH, HOUSE_HEIGHT, WALL_THICKNESS); const wallBackMesh = new THREE.Mesh(wallBackGeometry, wallMaterial.clone()); wallBackMesh.position.z = -HOUSE_DEPTH / 2 + WALL_THICKNESS / 2; wallBackMesh.castShadow = true; wallBackMesh.receiveShadow = true; houseGroup.add(wallBackMesh); collidableMeshes.push(wallBackMesh); const wallLeftGeometry = new THREE.BoxGeometry(WALL_THICKNESS, HOUSE_HEIGHT, HOUSE_DEPTH); const wallLeftMesh = new THREE.Mesh(wallLeftGeometry, wallMaterial.clone()); wallLeftMesh.position.x = -HOUSE_WIDTH / 2 + WALL_THICKNESS / 2; wallLeftMesh.castShadow = true; wallLeftMesh.receiveShadow = true; houseGroup.add(wallLeftMesh); collidableMeshes.push(wallLeftMesh); const wallRightGeometry = new THREE.BoxGeometry(WALL_THICKNESS, HOUSE_HEIGHT, HOUSE_DEPTH); const wallRightMesh = new THREE.Mesh(wallRightGeometry, wallMaterial.clone()); wallRightMesh.position.x = HOUSE_WIDTH / 2 - WALL_THICKNESS / 2; wallRightMesh.castShadow = true; wallRightMesh.receiveShadow = true; houseGroup.add(wallRightMesh); collidableMeshes.push(wallRightMesh); const frontWallZ = HOUSE_DEPTH / 2 - WALL_THICKNESS / 2; const doorCutoutY = -HOUSE_HEIGHT/2 + DOOR_HEIGHT; if (DOOR_HEIGHT < HOUSE_HEIGHT) { const wallFrontBottomGeo = new THREE.BoxGeometry(HOUSE_WIDTH, HOUSE_HEIGHT - DOOR_HEIGHT, WALL_THICKNESS); const wallFrontBottomMesh = new THREE.Mesh(wallFrontBottomGeo, wallMaterial.clone()); wallFrontBottomMesh.position.set(0, doorCutoutY + (HOUSE_HEIGHT - DOOR_HEIGHT)/2 , frontWallZ); wallFrontBottomMesh.castShadow = true; wallFrontBottomMesh.receiveShadow = true; houseGroup.add(wallFrontBottomMesh); collidableMeshes.push(wallFrontBottomMesh); } const leftWallWidth = (HOUSE_WIDTH - DOOR_WIDTH) / 2; if (leftWallWidth > 0) { const wallFrontLeftGeo = new THREE.BoxGeometry(leftWallWidth, DOOR_HEIGHT, WALL_THICKNESS); const wallFrontLeftMesh = new THREE.Mesh(wallFrontLeftGeo, wallMaterial.clone()); wallFrontLeftMesh.position.set(- (DOOR_WIDTH / 2) - (leftWallWidth / 2), -HOUSE_HEIGHT/2 + DOOR_HEIGHT/2, frontWallZ); wallFrontLeftMesh.castShadow = true; wallFrontLeftMesh.receiveShadow = true; houseGroup.add(wallFrontLeftMesh); collidableMeshes.push(wallFrontLeftMesh); } const rightWallWidth = (HOUSE_WIDTH - DOOR_WIDTH) / 2; if (rightWallWidth > 0) { const wallFrontRightGeo = new THREE.BoxGeometry(rightWallWidth, DOOR_HEIGHT, WALL_THICKNESS); const wallFrontRightMesh = new THREE.Mesh(wallFrontRightGeo, wallMaterial.clone()); wallFrontRightMesh.position.set((DOOR_WIDTH / 2) + (rightWallWidth / 2), -HOUSE_HEIGHT/2 + DOOR_HEIGHT/2, frontWallZ); wallFrontRightMesh.castShadow = true; wallFrontRightMesh.receiveShadow = true; houseGroup.add(wallFrontRightMesh); collidableMeshes.push(wallFrontRightMesh); } const frameThickness = DOOR_FRAME_THICKNESS; const frameColor = 0x502A0F; const frameMat = new THREE.MeshStandardMaterial({color: frameColor, roughness: 0.8}); const lintelGeo = new THREE.BoxGeometry(DOOR_WIDTH + 2*frameThickness, frameThickness, WALL_THICKNESS + frameThickness); const lintelMesh = new THREE.Mesh(lintelGeo, frameMat); lintelMesh.position.set(0, -HOUSE_HEIGHT/2 + DOOR_HEIGHT + frameThickness/2, frontWallZ); houseGroup.add(lintelMesh); collidableMeshes.push(lintelMesh); const jambGeo = new THREE.BoxGeometry(frameThickness, DOOR_HEIGHT + frameThickness, WALL_THICKNESS + frameThickness); const jambLeftMesh = new THREE.Mesh(jambGeo, frameMat); jambLeftMesh.position.set(-DOOR_WIDTH/2 - frameThickness/2, -HOUSE_HEIGHT/2 + (DOOR_HEIGHT + frameThickness)/2, frontWallZ); houseGroup.add(jambLeftMesh); collidableMeshes.push(jambLeftMesh); const jambRightMesh = new THREE.Mesh(jambGeo, frameMat); jambRightMesh.position.set(DOOR_WIDTH/2 + frameThickness/2, -HOUSE_HEIGHT/2 + (DOOR_HEIGHT + frameThickness)/2, frontWallZ); houseGroup.add(jambRightMesh); collidableMeshes.push(jambRightMesh); const internalLight = new THREE.PointLight(0xffeedd, 0.8, HOUSE_WIDTH * 1.2); internalLight.position.set(0, HOUSE_HEIGHT / 2 - 1, 0); internalLight.castShadow = true; internalLight.shadow.mapSize.width = 512; internalLight.shadow.mapSize.height = 512; internalLight.shadow.bias = -0.001; houseGroup.add(internalLight); internalLight.visible = false; scene.add(houseGroup); console.log(`Casa criada com ${collidableMeshes.length} meshes colidíveis.`); }
        function createChair() { if (!houseGroup) return; console.log("Criando cadeira..."); const chairGroup = new THREE.Group(); const chairMaterial = new THREE.MeshStandardMaterial({color: 0x654321, roughness: 0.7}); const seatGeo = new THREE.BoxGeometry(1, 0.15, 1); const seatMesh = new THREE.Mesh(seatGeo, chairMaterial); seatMesh.castShadow = true; seatMesh.receiveShadow = true; chairGroup.add(seatMesh); const backGeo = new THREE.BoxGeometry(1, 1.2, 0.1); const backMesh = new THREE.Mesh(backGeo, chairMaterial); backMesh.position.set(0, 0.6 + 0.15/2, -0.5 + 0.1/2); backMesh.castShadow = true; backMesh.receiveShadow = true; chairGroup.add(backMesh); const legGeo = new THREE.BoxGeometry(0.1, 0.8, 0.1); const legPositions = [ [0.45, -0.4, 0.45], [-0.45, -0.4, 0.45], [0.45, -0.4, -0.45], [-0.45, -0.4, -0.45] ]; legPositions.forEach(pos => { const legMesh = new THREE.Mesh(legGeo, chairMaterial); legMesh.position.set(pos[0], pos[1], pos[2]); legMesh.castShadow = true; legMesh.receiveShadow = true; chairGroup.add(legMesh); }); chairGroup.position.copy(CHAIR_POSITION_INSIDE_HOUSE); chairGroup.rotation.y = Math.PI; chairMesh = chairGroup; houseGroup.add(chairMesh); collidableMeshes.push(seatMesh, backMesh, ...chairGroup.children.filter(c => c.geometry === legGeo)); console.log("Cadeira criada e adicionada aos colidíveis."); }
        function createVideoScreen() { if (!houseGroup || !saganVideoElement) return; console.log("Criando tela vídeo..."); saganVideoTexture = new THREE.VideoTexture(saganVideoElement); saganVideoTexture.minFilter = THREE.LinearFilter; saganVideoTexture.magFilter = THREE.LinearFilter; saganVideoTexture.format = THREE.RGBFormat; const screenMaterial = new THREE.MeshBasicMaterial({ map: saganVideoTexture, side: THREE.FrontSide, toneMapped: false }); const screenGeometry = new THREE.PlaneGeometry(VIDEO_SCREEN_WIDTH, VIDEO_SCREEN_HEIGHT); videoScreenMesh = new THREE.Mesh(screenGeometry, screenMaterial); videoScreenMesh.position.copy(VIDEO_SCREEN_POSITION_INSIDE_HOUSE); videoScreenMesh.receiveShadow = true; houseGroup.add(videoScreenMesh); }
        function createRemoteControl() { if (!houseGroup) return; console.log("Criando controle..."); const remoteMaterial = new THREE.MeshStandardMaterial({color: 0x555555, roughness: 0.6}); textureLoader.load(REMOTE_TEXTURE_FILE, function(texture){ remoteMaterial.map = texture; remoteMaterial.needsUpdate = true; }, undefined, function(err){ console.error(`Erro textura controle:`, err); }); const remoteGeometry = new THREE.BoxGeometry(REMOTE_SIZE.width, REMOTE_SIZE.height, REMOTE_SIZE.depth); remoteMesh = new THREE.Mesh(remoteGeometry, remoteMaterial); remoteMesh.position.copy(REMOTE_POSITION_INSIDE_HOUSE); remoteMesh.castShadow = true; remoteMesh.receiveShadow = true; remoteMesh.rotation.x = -Math.PI / 3; houseGroup.add(remoteMesh); }
        function createBookshelf() { if (!houseGroup) { console.error("createBookshelf: Grupo da casa não existe!"); return; } console.log("Criando estante detalhada..."); bookshelfGroup = new THREE.Group(); const shelfWidth = 2.5; const shelfHeight = 3.0; const shelfDepth = 0.6; const woodThickness = 0.06; const shelfMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8, metalness: 0.1 }); const basePosX = -(HOUSE_WIDTH / 2) + WALL_THICKNESS + (shelfDepth / 2) + 0.05; const basePosY = HOUSE_FLOOR_Y_OFFSET + (shelfHeight / 2); const basePosZ = 0; bookshelfGroup.position.set(basePosX, basePosY, basePosZ); const backGeo = new THREE.BoxGeometry(woodThickness, shelfHeight, shelfWidth); const backMesh = new THREE.Mesh(backGeo, shelfMaterial); backMesh.position.x = -shelfDepth / 2 + woodThickness / 2; backMesh.castShadow = true; backMesh.receiveShadow = true; bookshelfGroup.add(backMesh); collidableMeshes.push(backMesh); const sideGeo = new THREE.BoxGeometry(shelfDepth, shelfHeight, woodThickness); const leftSideMesh = new THREE.Mesh(sideGeo, shelfMaterial); leftSideMesh.position.z = -shelfWidth / 2 + woodThickness / 2; leftSideMesh.castShadow = true; leftSideMesh.receiveShadow = true; bookshelfGroup.add(leftSideMesh); collidableMeshes.push(leftSideMesh); const rightSideMesh = new THREE.Mesh(sideGeo, shelfMaterial); rightSideMesh.position.z = shelfWidth / 2 - woodThickness / 2; rightSideMesh.castShadow = true; rightSideMesh.receiveShadow = true; bookshelfGroup.add(rightSideMesh); collidableMeshes.push(rightSideMesh); const shelfBoardWidth = shelfWidth - 2 * woodThickness; const shelfBoardGeo = new THREE.BoxGeometry(shelfDepth - woodThickness, woodThickness, shelfBoardWidth); const shelfBoardPosX = 0; const bottomShelfMesh = new THREE.Mesh(shelfBoardGeo, shelfMaterial); bottomShelfMesh.position.y = -shelfHeight / 2 + woodThickness / 2; bottomShelfMesh.position.x = shelfBoardPosX; bottomShelfMesh.castShadow = true; bottomShelfMesh.receiveShadow = true; bookshelfGroup.add(bottomShelfMesh); collidableMeshes.push(bottomShelfMesh); const topShelfMesh = new THREE.Mesh(shelfBoardGeo, shelfMaterial); topShelfMesh.position.y = shelfHeight / 2 - woodThickness / 2; topShelfMesh.position.x = shelfBoardPosX; topShelfMesh.castShadow = true; topShelfMesh.receiveShadow = true; bookshelfGroup.add(topShelfMesh); collidableMeshes.push(topShelfMesh); const middleShelfMesh = new THREE.Mesh(shelfBoardGeo, shelfMaterial); const middleShelfPosY = 0; middleShelfMesh.position.y = middleShelfPosY; middleShelfMesh.position.x = shelfBoardPosX; middleShelfMesh.castShadow = true; middleShelfMesh.receiveShadow = true; bookshelfGroup.add(middleShelfMesh); collidableMeshes.push(middleShelfMesh); const bookHeight = 0.7; const bookDepth = 0.5; const bookWidth = 0.12; const bookGeo = new THREE.BoxGeometry(bookWidth, bookHeight, bookDepth); const bookPosY = middleShelfPosY + (woodThickness / 2) + (bookHeight / 2) + 0.01; const bookPosX = shelfBoardPosX - (shelfDepth - woodThickness)/2 + bookWidth/2 + 0.05 ; const bookColors = [0xff0000, 0x0000ff, 0x00ff00]; const bookZPositions = [-shelfBoardWidth * 0.3, 0, shelfBoardWidth * 0.3]; const bookRotations = [Math.PI / 16, -Math.PI / 20, -Math.PI / 10]; bookMeshes = []; for (let i = 0; i < 3; i++) { const bookMaterial = new THREE.MeshStandardMaterial({ color: bookColors[i], roughness: 0.7, emissive: 0x000000 }); const bookMesh = new THREE.Mesh(bookGeo, bookMaterial); bookMesh.castShadow = true; bookMesh.receiveShadow = true; bookMesh.position.set(bookPosX, bookPosY, bookZPositions[i]); bookMesh.rotation.y = bookRotations[i]; bookshelfGroup.add(bookMesh); bookMeshes.push(bookMesh); } houseGroup.add(bookshelfGroup); console.log("Estante criada e adicionada aos colidíveis."); }
        function createTable() { if (!houseGroup) { console.error("createTable: Grupo da casa não existe!"); return; } console.log("Criando mesa reposicionada com itens..."); tableGroup = new THREE.Group(); const legThickness = 0.08; const topThickness = 0.05; const tableMaterial = new THREE.MeshStandardMaterial({ color: 0x966F33, roughness: 0.8, metalness: 0.1 }); const topGeo = new THREE.BoxGeometry(TABLE_WIDTH, topThickness, TABLE_DEPTH); const topMesh = new THREE.Mesh(topGeo, tableMaterial); topMesh.position.y = TABLE_HEIGHT - (topThickness / 2); topMesh.castShadow = true; topMesh.receiveShadow = true; topMesh.userData.isPlaceable = true; tableGroup.add(topMesh); collidableMeshes.push(topMesh); placeableMeshes.push(topMesh); const legHeight = TABLE_HEIGHT - topThickness; const legGeo = new THREE.BoxGeometry(legThickness, legHeight, legThickness); const legOffsetY = legHeight / 2; const legOffsetX = TABLE_WIDTH / 2 - legThickness / 2 - 0.02; const legOffsetZ = TABLE_DEPTH / 2 - legThickness / 2 - 0.02; const legPositions = [ { x: legOffsetX, z: legOffsetZ }, { x: -legOffsetX, z: legOffsetZ }, { x: legOffsetX, z: -legOffsetZ }, { x: -legOffsetX, z: -legOffsetZ }, ]; legPositions.forEach(pos => { const legMesh = new THREE.Mesh(legGeo, tableMaterial); legMesh.position.set(pos.x, legOffsetY, pos.z); legMesh.castShadow = true; legMesh.receiveShadow = true; tableGroup.add(legMesh); collidableMeshes.push(legMesh); }); const cubeSize = 0.2; const cubeGeo = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize); const cubeMat = new THREE.MeshStandardMaterial({ color: 0x00aaff, roughness: 0.4, metalness: 0.2, emissive: 0x003366, emissiveIntensity: 0.4 }); cubelandiaCubeMesh = new THREE.Mesh(cubeGeo, cubeMat); cubelandiaCubeMesh.position.set( -TABLE_WIDTH * 0.3, TABLE_HEIGHT + (cubeSize / 2), 0 ); cubelandiaCubeMesh.castShadow = true; cubelandiaCubeMesh.receiveShadow = true; cubelandiaCubeMesh.rotation.y = Math.PI / 6; tableGroup.add(cubelandiaCubeMesh); appleGroup = new THREE.Group(); const appleRadius = 0.08; const appleGeo = new THREE.SphereGeometry(appleRadius, 24, 16); const appleMat = new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.6, metalness: 0.1 }); const appleMesh = new THREE.Mesh(appleGeo, appleMat); appleMesh.castShadow = true; appleMesh.receiveShadow = true; appleGroup.add(appleMesh); const stemHeight = 0.06; const stemRadius = 0.01; const stemGeo = new THREE.CylinderGeometry(stemRadius * 0.8, stemRadius, stemHeight, 8); const stemMat = new THREE.MeshStandardMaterial({ color: 0x5C4033, roughness: 0.9 }); const stemMesh = new THREE.Mesh(stemGeo, stemMat); stemMesh.position.y = appleRadius + stemHeight / 2 - 0.01; stemMesh.castShadow = true; appleGroup.add(stemMesh); appleGroup.position.set( TABLE_WIDTH * 0.3, TABLE_HEIGHT + appleRadius, TABLE_DEPTH * 0.1 ); tableGroup.add(appleGroup); tableGroup.position.set( TABLE_POSITION_INSIDE_HOUSE_X, TABLE_POSITION_INSIDE_HOUSE_Y, TABLE_POSITION_INSIDE_HOUSE_Z ); houseGroup.add(tableGroup); console.log("Mesa criada e adicionada aos colidíveis na nova posição."); }
        function createComputer() { if (!tableGroup) { console.error("createComputer: Mesa não existe!"); return; } console.log("Criando computador na mesa..."); const monitorWidth = 0.6; const monitorHeight = 0.4; const monitorDepth = 0.05; const standHeight = 0.1; const standRadius = 0.08; const keyboardWidth = 0.5; const keyboardHeight = 0.02; const keyboardDepth = 0.18; const computerMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.7, metalness: 0.4 }); const screenPlaceholderColor = 0x111122; computerScreenMaterial = new THREE.MeshBasicMaterial({ color: screenPlaceholderColor, side: THREE.DoubleSide }); const computerGroup = new THREE.Group(); const monitorScreenGeo = new THREE.PlaneGeometry(monitorWidth - 0.04, monitorHeight - 0.04); computerMonitorMesh = new THREE.Mesh(monitorScreenGeo, computerScreenMaterial); computerMonitorMesh.position.set(0, standHeight + monitorHeight / 2, monitorDepth / 2 + 0.001); computerGroup.add(computerMonitorMesh); const monitorFrameGeo = new THREE.BoxGeometry(monitorWidth, monitorHeight, monitorDepth); const monitorFrameMesh = new THREE.Mesh(monitorFrameGeo, computerMaterial); monitorFrameMesh.position.y = standHeight + monitorHeight / 2; monitorFrameMesh.castShadow = true; monitorFrameMesh.receiveShadow = true; computerGroup.add(monitorFrameMesh); collidableMeshes.push(monitorFrameMesh); const standGeo = new THREE.CylinderGeometry(standRadius * 0.5, standRadius, standHeight, 16); const standMesh = new THREE.Mesh(standGeo, computerMaterial); standMesh.position.y = standHeight / 2; standMesh.castShadow = true; standMesh.receiveShadow = true; computerGroup.add(standMesh); collidableMeshes.push(standMesh); const keyboardGeo = new THREE.BoxGeometry(keyboardWidth, keyboardHeight, keyboardDepth); const keyboardMesh = new THREE.Mesh(keyboardGeo, computerMaterial); keyboardMesh.position.set(0, keyboardHeight / 2, keyboardDepth / 2 + 0.1); keyboardMesh.castShadow = true; keyboardMesh.receiveShadow = true; computerGroup.add(keyboardMesh); collidableMeshes.push(keyboardMesh); computerGroup.position.set(0, TABLE_HEIGHT, -TABLE_DEPTH * 0.2); tableGroup.add(computerGroup); console.log("Computador criado."); }
        function createPath() { console.log("Criando caminho externo..."); const pathMaterial = new THREE.MeshStandardMaterial({ roughness: 0.9, metalness: 0.05 }); textureLoader.load(PATH_TEXTURE_FILE, (t) => { t.wrapS = t.wrapT = THREE.RepeatWrapping; t.repeat.set(PATH_TEXTURE_REPEAT_X, PATH_TEXTURE_REPEAT_Z); pathMaterial.map = t; pathMaterial.needsUpdate = true; }, undefined, (e) => { console.error('Erro Textura Caminho'); pathMaterial.color.set(0x7c7a7a); }); const pathGeometry = new THREE.BoxGeometry(PATH_WIDTH, PATH_THICKNESS, PATH_LENGTH); pathMesh = new THREE.Mesh(pathGeometry, pathMaterial); const pathPosX = HOUSE_POSITION.x; const pathPosY = HOUSE_POSITION.y + PATH_Y_OFFSET; const pathPosZ = HOUSE_POSITION.z + HOUSE_DEPTH / 2 + PATH_LENGTH / 2; pathMesh.position.set(pathPosX, pathPosY, pathPosZ); pathMesh.receiveShadow = true; pathMesh.userData.isGround = true; scene.add(pathMesh); const pathHalfWidth = PATH_WIDTH / 2; const pathHalfLength = PATH_LENGTH / 2; pathMinBounds.set(pathPosX - pathHalfWidth, pathPosY - PATH_THICKNESS, pathPosZ - pathHalfLength); pathMaxBounds.set(pathPosX + pathHalfWidth, pathPosY + PATH_THICKNESS, pathPosZ + pathHalfLength); console.log("Caminho criado em:", pathMesh.position); console.log("Limites Caminho (min):", pathMinBounds); console.log("Limites Caminho (max):", pathMaxBounds); }
        function createLamp() { if (!houseGroup || !tableGroup) { console.error("createLamp: Pré-requisitos (casa/mesa) não existem!"); return; } console.log("Criando lâmpada na mesa..."); lampGroup = new THREE.Group(); const lampBaseHeight = 0.05; const lampStemHeight = 0.4; const lampShadeHeight = 0.15; const lampBaseRadius = 0.1; const lampStemRadius = 0.02; const lampShadeRadiusTop = 0.05; const lampShadeRadiusBottom = 0.15; const lampMaterial = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.4, metalness: 0.7 }); const buttonMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.6, emissive: 0x550000 }); const baseGeo = new THREE.CylinderGeometry(lampBaseRadius, lampBaseRadius, lampBaseHeight, 16); const baseMesh = new THREE.Mesh(baseGeo, lampMaterial); baseMesh.position.y = lampBaseHeight / 2; baseMesh.castShadow = true; baseMesh.receiveShadow = true; lampGroup.add(baseMesh); collidableMeshes.push(baseMesh); const stemGeo = new THREE.CylinderGeometry(lampStemRadius, lampStemRadius, lampStemHeight, 8); const stemMesh = new THREE.Mesh(stemGeo, lampMaterial); stemMesh.position.y = lampBaseHeight + lampStemHeight / 2; stemMesh.castShadow = true; stemMesh.receiveShadow = true; lampGroup.add(stemMesh); collidableMeshes.push(stemMesh); const shadeGeo = new THREE.CylinderGeometry(lampShadeRadiusTop, lampShadeRadiusBottom, lampShadeHeight, 16, 1, true); const shadeMesh = new THREE.Mesh(shadeGeo, lampMaterial); shadeMesh.position.y = lampBaseHeight + lampStemHeight + lampShadeHeight / 2; shadeMesh.castShadow = true; lampGroup.add(shadeMesh); const buttonSize = 0.04; const buttonGeo = new THREE.BoxGeometry(buttonSize, buttonSize, buttonSize); lampButtonMesh = new THREE.Mesh(buttonGeo, buttonMaterial); lampButtonMesh.position.set(lampBaseRadius * 0.6, lampBaseHeight + buttonSize, 0); lampGroup.add(lampButtonMesh); lampLight = new THREE.PointLight(LAMP_LIGHT_COLOR, 0, LAMP_LIGHT_DISTANCE, LAMP_LIGHT_DECAY); lampLight.position.y = lampBaseHeight + lampStemHeight + lampShadeHeight * 0.2; lampLight.castShadow = true; lampLight.shadow.mapSize.width = 1024; lampLight.shadow.mapSize.height = 1024; lampLight.shadow.bias = -0.005; lampLight.shadow.radius = 4; lampGroup.add(lampLight); isLampOn = false; toggleLamp(true, false); const lampPosXRelative = TABLE_WIDTH * 0.35; const lampPosZRelative = TABLE_DEPTH * 0.3; lampGroup.position.set(lampPosXRelative, TABLE_HEIGHT, -lampPosZRelative); tableGroup.add(lampGroup); console.log("Lâmpada criada sobre a mesa."); }
        function createExteriorLamp() { console.log("Criando lâmpada externa..."); const lightPosX = HOUSE_POSITION.x; const lightPosY = HOUSE_POSITION.y - HOUSE_HEIGHT / 2 + DOOR_HEIGHT + 0.5; const lightPosZ = HOUSE_POSITION.z + HOUSE_DEPTH / 2 + WALL_THICKNESS + 0.1; exteriorLamp = new THREE.SpotLight( EXTERIOR_LAMP_COLOR, EXTERIOR_LAMP_INTENSITY, EXTERIOR_LAMP_DISTANCE, EXTERIOR_LAMP_ANGLE, EXTERIOR_LAMP_PENUMBRA, EXTERIOR_LAMP_DECAY ); exteriorLamp.position.set(lightPosX, lightPosY, lightPosZ); exteriorLamp.castShadow = true; exteriorLamp.shadow.mapSize.width = 1024; exteriorLamp.shadow.mapSize.height = 1024; exteriorLamp.shadow.bias = -0.01; const targetObject = new THREE.Object3D(); targetObject.position.set(lightPosX, 0, lightPosZ + 5); scene.add(targetObject); exteriorLamp.target = targetObject; scene.add(exteriorLamp); const fixtureMaterial = new THREE.MeshStandardMaterial({color: 0x444444, metalness: 0.8, roughness: 0.5}); const fixtureGeo = new THREE.BoxGeometry(0.3, 0.3, 0.3); const fixtureMesh = new THREE.Mesh(fixtureGeo, fixtureMaterial); fixtureMesh.position.copy(exteriorLamp.position); scene.add(fixtureMesh); console.log("Lâmpada externa criada."); }
        function createPlacedCameraVisual(position, lookAtTarget, color) { const cameraBodySize = 0.15; const lensRadius = 0.04; const lensLength = 0.08; const bodyMat = new THREE.MeshStandardMaterial({color: color, roughness: 0.6}); const bodyGeo = new THREE.BoxGeometry(cameraBodySize, cameraBodySize * 0.8, cameraBodySize * 0.6); const newCameraMesh = new THREE.Mesh(bodyGeo, bodyMat); const lensGeo = new THREE.CylinderGeometry(lensRadius, lensRadius, lensLength, 16); const lensMat = new THREE.MeshStandardMaterial({color: 0x555555, roughness: 0.4, metalness: 0.2}); const lensMesh = new THREE.Mesh(lensGeo, lensMat); lensMesh.rotation.x = Math.PI / 2; lensMesh.position.z = cameraBodySize * 0.3 + lensLength / 2; newCameraMesh.add(lensMesh); newCameraMesh.position.copy(position); newCameraMesh.lookAt(lookAtTarget); newCameraMesh.castShadow = true; newCameraMesh.receiveShadow = true; return newCameraMesh; }
        function createCircuitBreaker() { if (!houseGroup) return; console.log("Criando disjuntor..."); const breakerSize = { w: 0.15, h: 0.25, d: 0.08 }; const breakerGeo = new THREE.BoxGeometry(breakerSize.w, breakerSize.h, breakerSize.d); const breakerMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.4, metalness: 0.3 }); circuitBreakerMesh = new THREE.Mesh(breakerGeo, breakerMat); const posX = DOOR_WIDTH / 2 + DOOR_FRAME_THICKNESS + breakerSize.w / 2 + 0.1; const posY = HOUSE_FLOOR_Y_OFFSET + breakerSize.h / 2 + 0.4; const posZ = HOUSE_DEPTH / 2 - WALL_THICKNESS - breakerSize.d / 2 - 0.05; circuitBreakerMesh.position.set(posX, posY, posZ); circuitBreakerMesh.rotation.y = 0; circuitBreakerMesh.castShadow = true; circuitBreakerMesh.receiveShadow = true; houseGroup.add(circuitBreakerMesh); collidableMeshes.push(circuitBreakerMesh); console.log("Disjuntor criado em (local):", circuitBreakerMesh.position); }
        function createWallSocket() { if (!houseGroup || !circuitBreakerMesh) return; console.log("Criando tomada..."); const socketSize = { w: 0.08, h: 0.12, d: 0.03 }; const socketGeo = new THREE.BoxGeometry(socketSize.w, socketSize.h, socketSize.d); const socketMat = new THREE.MeshStandardMaterial({ color: 0xfff8dc, roughness: 0.7, metalness: 0.1 }); wallSocketMesh = new THREE.Mesh(socketGeo, socketMat); const breakerPos = circuitBreakerMesh.position; const posX = breakerPos.x - (circuitBreakerMesh.geometry.parameters.width / 2) - (socketSize.w / 2) - 0.1; const posY = breakerPos.y; const posZ = breakerPos.z; wallSocketMesh.position.set(posX, posY, posZ); wallSocketMesh.rotation.y = 0; wallSocketMesh.castShadow = true; wallSocketMesh.receiveShadow = true; houseGroup.add(wallSocketMesh); collidableMeshes.push(wallSocketMesh); console.log("Tomada criada em (local):", wallSocketMesh.position); }

        function createFlashlight() {
            console.log("Criando lanterna (SpotLight na Cena)...");
            flashlight = new THREE.SpotLight(
                FLASHLIGHT_COLOR, 0, FLASHLIGHT_DISTANCE, FLASHLIGHT_ANGLE, FLASHLIGHT_PENUMBRA, FLASHLIGHT_DECAY
            );
            flashlight.position.set(0, 0, 0);
            flashlight.castShadow = false;

            flashlight.target = new THREE.Object3D();

            scene.add(flashlight);
            scene.add(flashlight.target);

            flashlightHelper = null;

            isFlashlightOn = false;
            flashlightEnergy = FLASHLIGHT_MAX_ENERGY;
            console.log("Lanterna (SpotLight) e Alvo adicionados à cena.");
        }

        function setupAudio() { if (!videoScreenMesh || !listener) { console.error("setupAudio: Pré-requisitos não prontos!"); return; } console.log(`Configurando PositionalAudio para ${BACKGROUND_MUSIC_FILE}...`); const audioLoader = new THREE.AudioLoader(); backgroundMusic = new THREE.PositionalAudio(listener); audioLoader.load(BACKGROUND_MUSIC_FILE, function(buffer) { console.log(`Buffer ${BACKGROUND_MUSIC_FILE} carregado.`); try { backgroundMusic.setBuffer(buffer); backgroundMusic.setLoop(true); backgroundMusic.setVolume(INITIAL_VOLUME); backgroundMusic.setRefDistance(AUDIO_REF_DISTANCE); backgroundMusic.setRolloffFactor(AUDIO_ROLLOFF_FACTOR); backgroundMusic.setMaxDistance(AUDIO_MAX_DISTANCE); videoScreenMesh.add(backgroundMusic); console.log("PositionalAudio MP3 anexado à TV."); updateVolumeMessage(); console.log(`Áudio MP3 config. Vol: ${INITIAL_VOLUME}, Params: ${AUDIO_REF_DISTANCE}, ${AUDIO_ROLLOFF_FACTOR}, ${AUDIO_MAX_DISTANCE}`); } catch (e) { console.error("Erro config PositionalAudio MP3:", e); volumeControlDiv.textContent = "Erro áudio MP3"; volumeControlDiv.style.display = 'block'; backgroundMusic = null; } }, (xhr) => {  }, (err) => { console.error(`Erro load ${BACKGROUND_MUSIC_FILE}:`, err); volumeControlDiv.textContent = "Erro load MP3"; volumeControlDiv.style.display = 'block'; backgroundMusic = null; }); }

        function startGame() { if (gameStarted || isTransitioning || !mainFont) { return; } console.log("Iniciando exploração..."); gameStarted = true; isTransitioning = true; configPanel.style.display = 'none'; if (menuGroup) { scene.remove(menuGroup); if(playTextMesh?.geometry) playTextMesh.geometry.dispose(); if(playTextMesh?.material) playTextMesh.material.dispose(); if(configTextMesh?.geometry) configTextMesh.geometry.dispose(); if(configTextMesh?.material) configTextMesh.material.dispose(); menuGroup = null; playTextMesh = null; configTextMesh = null; } createHouse(); createPath(); createExteriorLamp(); createChair(); createVideoScreen(); createRemoteControl(); createBookshelf(); createTable(); createComputer(); createLamp(); createCircuitBreaker(); createWallSocket(); createFlashlight(); setupAudio(); createPhysicsBlocks(); currentEnergy = MAX_ENERGY; flashlightEnergy = FLASHLIGHT_MAX_ENERGY; isPowerOut = false; powerStatusMessageDiv.style.display = 'block'; flashlightStatusMessageDiv.style.display = 'block'; cameraRenderTarget = new THREE.WebGLRenderTarget(CAMERA_RENDER_TARGET_WIDTH, CAMERA_RENDER_TARGET_HEIGHT, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBFormat }); console.log("Render Target da câmera inicializado."); tryResumeAudioContext(listener.context); if (saganVideoElement) { saganVideoElement.load(); } renderer.domElement.requestPointerLock(); isTransitioning = false; console.log("Exploração iniciada."); }
        function displayBookContent(index) { if (index < 0 || !bookMeshes || index >= bookMeshes.length || !bookMeshes[index]) { console.warn("Índice livro inválido ou mesh não encontrado:", index); closeBook(); return; } if (!bookContents || index >= bookContents.length) { console.warn("Índice livro inválido ou conteúdo não definido:", index); closeBook(); return; } console.log(`Focando livro ${index+1}`); selectedBookIndex = index; isInBookView = true; freezePlayer = true; preBookViewPos.copy(camera.position); preBookViewQuat.copy(camera.quaternion); const targetPos = new THREE.Vector3(); const bookshelfCenter = new THREE.Vector3(); bookshelfGroup.getWorldPosition(bookshelfCenter); targetPos.set(bookshelfCenter.x - 2, bookshelfCenter.y + 0.5, bookshelfCenter.z); camera.position.copy(targetPos); camera.lookAt(bookshelfCenter); if (bookContentTextElement && bookContentDisplayDiv) { bookContentTextElement.textContent = bookContents[index]; bookContentDisplayDiv.style.display = 'block'; } if (document.pointerLockElement) { document.exitPointerLock(); } if (bookshelfInteractionMessageDiv) bookshelfInteractionMessageDiv.style.display = 'none'; if (bookshelfOpenMessageDiv) bookshelfOpenMessageDiv.style.display = 'none'; }
        function closeBook() { if(!isInBookView)return;console.log("Fechando livro.");if(bookContentDisplayDiv)bookContentDisplayDiv.style.display='none';camera.position.copy(preBookViewPos);camera.quaternion.copy(preBookViewQuat);isInBookView=false;selectedBookIndex=-1;freezePlayer=false;if(isBookshelfInteractionOpen){if(!document.pointerLockElement&&gameStarted&&!isSitting&&configPanel.style.display==='none'){renderer.domElement.requestPointerLock();}} }
        function toggleSit() { if (!chairMesh || isTransitioningCamera || isPowerOut) return; if (!isSitting) { const sitOffsetLocal = new THREE.Vector3(0, 0.8, -0.2); targetCameraPos.copy(sitOffsetLocal); chairMesh.localToWorld(targetCameraPos); if (videoScreenMesh) { videoScreenMesh.getWorldPosition(targetCameraLookAt); targetCameraLookAt.y += VIDEO_SCREEN_HEIGHT * 0.1; } else { const lookDirection = new THREE.Vector3(0, 0, -1); const chairWorldQuaternion = _worldQuaternion; chairMesh.getWorldQuaternion(chairWorldQuaternion); lookDirection.applyQuaternion(chairWorldQuaternion); targetCameraLookAt.copy(targetCameraPos).add(lookDirection.multiplyScalar(5)); } originalCameraPos.copy(camera.position); originalCameraQuat.copy(camera.quaternion); freezePlayer = true; isTransitioningCamera = true; console.log("Sentando..."); } else { targetCameraPos.copy(originalCameraPos); freezePlayer = true; isTransitioningCamera = true; console.log("Levantando..."); if(saganVideoElement && !saganVideoElement.paused) { saganVideoElement.pause(); console.log("Vídeo pausado."); } if(backgroundMusic && backgroundMusic.isPlaying) { backgroundMusic.pause(); console.log("Música pausada."); } } }
        function grabRemote() { if (!remoteMesh || hasRemoteControl || isPowerOut) return; const remoteWorldPos = new THREE.Vector3(); remoteMesh.getWorldPosition(remoteWorldPos); if (camera.position.distanceTo(remoteWorldPos) < REMOTE_INTERACTION_RANGE) { console.log("Controle pego!"); hasRemoteControl = true; remoteMesh.visible = false; videoControlDiv.textContent = `Controle: [${VIDEO_PAUSE_KEY.toUpperCase()}]Pausar [${VIDEO_START_KEY.toUpperCase()}]Iniciar`; remoteInteractionMessageDiv.style.display = 'none'; updateVolumeMessage(); } }
        function updateVolumeMessage() { if (backgroundMusic && hasRemoteControl) { const currentVolumePercent = Math.round(backgroundMusic.getVolume() * 100); volumeControlDiv.textContent = `Volume: ${currentVolumePercent}% [${VOLUME_DOWN_KEY.toUpperCase()}]- / [${VOLUME_UP_KEY.toUpperCase()}]+`; } else { volumeControlDiv.style.display = 'none'; } }
        function toggleLamp(forceState = false, state) { if (!lampLight || !lampButtonMesh) return; const newState = forceState ? state : !isLampOn; if (newState === true && isPowerOut) { console.log("Não é possível ligar a lâmpada: sem energia."); return; } isLampOn = newState; lampLight.intensity = isLampOn ? DEFAULT_LAMP_INTENSITY : 0; if (isLampOn) { lampButtonMesh.material.color.setHex(0x00ff00); lampButtonMesh.material.emissive.setHex(0x005500); } else { lampButtonMesh.material.color.setHex(0xff0000); lampButtonMesh.material.emissive.setHex(0x550000); } lampButtonMesh.material.needsUpdate = true; if (!forceState) { console.log(`Lâmpada ${isLampOn ? 'ligada' : 'desligada'}.`); } }

        function toggleFlashlight() {
            if (!flashlight) return;
            if (!isFlashlightOn) {
                if (flashlightEnergy > 0) {
                    isFlashlightOn = true;
                    flashlight.intensity = FLASHLIGHT_INTENSITY;
                    console.log("Lanterna Ligada. Intensidade:", flashlight.intensity);
                } else { console.log("Lanterna sem bateria."); }
            } else {
                isFlashlightOn = false;
                flashlight.intensity = 0;
                console.log("Lanterna Desligada.");
            }
        }

        function triggerPowerOutage() { if (isPowerOut) return; console.warn("QUEDA DE ENERGIA!"); isPowerOut = true; if (isRechargingFlashlight) { isRechargingFlashlight = false; freezePlayer = false; flashlightRechargeMessageDiv.style.display = 'none'; console.log("Recarga da lanterna interrompida pela queda de energia."); } wasLampOnBeforeOutage = isLampOn; if (isLampOn) { toggleLamp(true, false); } else if (lampButtonMesh) { lampButtonMesh.material.color.setHex(0xff0000); lampButtonMesh.material.emissive.setHex(0x550000); lampButtonMesh.material.needsUpdate = true; } if (exteriorLamp) exteriorLamp.intensity = 0; if (ambientLight) ambientLight.intensity = POWER_OUT_AMBIENT_INTENSITY; wasVideoPlayingBeforeOutage = saganVideoElement && !saganVideoElement.paused; videoVolumeBeforeOutage = backgroundMusic ? backgroundMusic.getVolume() : INITIAL_VOLUME; if(saganVideoElement) saganVideoElement.pause(); if(backgroundMusic && backgroundMusic.isPlaying) backgroundMusic.pause(); videoControlDiv.style.display = 'none'; volumeControlDiv.style.display = 'none'; powerStatusMessageDiv.textContent = "ENERGIA CASA: OFF"; powerStatusMessageDiv.style.color = "#ff4444"; if (computerScreenMaterial) { computerScreenMaterial.map = null; computerScreenMaterial.color.setHex(0x000000); computerScreenMaterial.needsUpdate = true; console.log("Tela do PC apagada devido à queda de energia."); } }
        function restoreDevicesVisuals() { console.log("Restaurando visuais/áudio dos aparelhos..."); toggleLamp(true, wasLampOnBeforeOutage); if (exteriorLamp) exteriorLamp.intensity = EXTERIOR_LAMP_INTENSITY; if (ambientLight) ambientLight.intensity = INITIAL_AMBIENT_INTENSITY; if (computerScreenMaterial) { if (wasVideoPlayingBeforeOutage && hasRemoteControl && saganVideoTexture) { computerScreenMaterial.map = saganVideoTexture; computerScreenMaterial.color.setHex(0xffffff); console.log("Restaurando textura do vídeo na tela do PC."); } else { computerScreenMaterial.map = null; computerScreenMaterial.color.setHex(0x111122); console.log("Restaurando cor placeholder na tela do PC."); } computerScreenMaterial.needsUpdate = true; } if (wasVideoPlayingBeforeOutage && hasRemoteControl) { console.log("Restaurando vídeo/áudio..."); if(backgroundMusic) backgroundMusic.setVolume(videoVolumeBeforeOutage); tryResumeAudioContext(listener.context, () => { if (saganVideoElement) { saganVideoElement.play().catch(e => console.warn("Play vídeo falhou ao restaurar energia:", e)); } if (backgroundMusic?.buffer && !backgroundMusic.isPlaying) { backgroundMusic.play(); } }); videoControlDiv.style.display = 'block'; volumeControlDiv.style.display = 'block'; } }

        function animate() {
            requestAnimationFrame(animate);
            var time = performance.now();
            const delta = clock.getDelta();

            if (isTransitioningCamera) { const lerpFactor = Math.min(delta * 5.0, 1.0); camera.position.lerp(targetCameraPos, lerpFactor); if (!isSitting) { const targetQuat = new THREE.Quaternion(); const tempMatrix = new THREE.Matrix4(); tempMatrix.lookAt(camera.position, targetCameraLookAt, camera.up); targetQuat.setFromRotationMatrix(tempMatrix); camera.quaternion.slerp(targetQuat, lerpFactor); } else { camera.quaternion.slerp(originalCameraQuat, lerpFactor); } const distThreshold = 0.05; const angleThreshold = 0.05; let targetQuatFinal; if(!isSitting){ const tempMatrixLookAt = new THREE.Matrix4().lookAt(targetCameraPos, targetCameraLookAt, camera.up); targetQuatFinal = new THREE.Quaternion().setFromRotationMatrix(tempMatrixLookAt); } else { targetQuatFinal = originalCameraQuat.clone(); } if (camera.position.distanceTo(targetCameraPos) < distThreshold && camera.quaternion.angleTo(targetQuatFinal) < angleThreshold) { camera.position.copy(targetCameraPos); if (isSitting) { camera.quaternion.copy(originalCameraQuat); freezePlayer = false; isSitting = false; console.log("Levantou."); } else { camera.lookAt(targetCameraLookAt); isSitting = true; console.log("Sentou."); } isTransitioningCamera = false; } }
            if (isTransitioningZoom) { const lerpFactor = Math.min(delta * 6.0, 1.0); let targetPos = isZoomedToComputer ? targetZoomPos : preZoomPos; let targetQuat; if (isZoomedToComputer) { const tempMatrix = new THREE.Matrix4().lookAt(camera.position, targetZoomLookAt, camera.up); targetQuat = new THREE.Quaternion().setFromRotationMatrix(tempMatrix); camera.fov = THREE.MathUtils.lerp(camera.fov, CAMERA_FOV_ZOOM, lerpFactor); } else { targetQuat = preZoomQuat; camera.fov = THREE.MathUtils.lerp(camera.fov, CAMERA_FOV_NORMAL, lerpFactor); } camera.position.lerp(targetPos, lerpFactor); camera.quaternion.slerp(targetQuat, lerpFactor); camera.updateProjectionMatrix(); const distThreshold = 0.05; const angleThreshold = 0.05; const fovThreshold = 0.5; if (camera.position.distanceTo(targetPos) < distThreshold && camera.quaternion.angleTo(targetQuat) < angleThreshold && Math.abs(camera.fov - (isZoomedToComputer ? CAMERA_FOV_ZOOM : CAMERA_FOV_NORMAL)) < fovThreshold) { camera.position.copy(targetPos); camera.quaternion.copy(targetQuat); camera.fov = isZoomedToComputer ? CAMERA_FOV_ZOOM : CAMERA_FOV_NORMAL; camera.updateProjectionMatrix(); isTransitioningZoom = false; if (!isZoomedToComputer) { freezePlayer = false; console.log("Zoom Out Completo."); } else { console.log("Zoom In Completo."); } } }

            const isHudVisible = gameStarted && !isTransitioning && !isSitting && !isInBookView && !isZoomedToComputer && !isRecharging && !isRechargingFlashlight && document.pointerLockElement === renderer.domElement && configPanel.style.display === 'none';
            hudCrosshair.style.display = isHudVisible ? 'block' : 'none';
            hudSpeed.style.display = isHudVisible ? 'block' : 'none';
            powerStatusMessageDiv.style.display = gameStarted ? 'block' : 'none';
            flashlightStatusMessageDiv.style.display = gameStarted ? 'block' : 'none';

            if (!gameStarted && menuGroup) { menuGroup.position.y = Math.sin(time * 0.001) * 0.3; menuGroup.rotation.y = Math.sin(time * 0.0005) * 0.2; }
            if (starField1) starField1.rotation.y += 0.00005; if (starField2) starField2.rotation.y -= 0.00008;

            if (gameStarted && !isTransitioning) {
                updateGravityZoneAndFloor();

                if (!isPowerOut && !isRecharging) { let totalDrainPerSec = ENERGY_DRAIN_BASE_PER_SEC; if (isLampOn) totalDrainPerSec += ENERGY_DRAIN_LAMP_INTERNAL_PER_SEC; if (exteriorLamp && exteriorLamp.intensity > 0) totalDrainPerSec += ENERGY_DRAIN_LAMP_EXTERNAL_PER_SEC; totalDrainPerSec += numCamerasPlaced * ENERGY_DRAIN_CAMERA_PER_SEC; currentEnergy -= totalDrainPerSec * delta; currentEnergy = Math.max(0, currentEnergy); powerStatusMessageDiv.textContent = `ENERGIA CASA: ${((currentEnergy / MAX_ENERGY) * 100).toFixed(0)}%`; powerStatusMessageDiv.style.color = currentEnergy < MAX_ENERGY * 0.2 ? "#ff8844" : "#ffccaa"; if (currentEnergy < POWER_OUTAGE_THRESHOLD) { triggerPowerOutage(); } } else if (isPowerOut) { powerStatusMessageDiv.textContent = "ENERGIA CASA: OFF"; powerStatusMessageDiv.style.color = "#ff4444"; } else if (isRecharging) { powerStatusMessageDiv.textContent = `Restaurando... ${rechargeTimer.toFixed(1)}s`; powerStatusMessageDiv.style.color = "#ffff99"; }

                if (isFlashlightOn && !isRechargingFlashlight) { flashlightEnergy -= FLASHLIGHT_DRAIN_PER_SEC * delta; flashlightEnergy = Math.max(0, flashlightEnergy); if (flashlightEnergy <= 0 && isFlashlightOn) { toggleFlashlight(); } }
                if (!isRechargingFlashlight) { flashlightStatusMessageDiv.textContent = `LANTERNA: ${((flashlightEnergy / FLASHLIGHT_MAX_ENERGY) * 100).toFixed(0)}%`; flashlightStatusMessageDiv.style.color = isFlashlightOn ? (flashlightEnergy < FLASHLIGHT_MAX_ENERGY * 0.2 ? "#ffcc55" : "#ccffcc") : "#88aa88"; } else { flashlightStatusMessageDiv.textContent = `LANTERNA: Recarregando...`; flashlightStatusMessageDiv.style.color = "#ccffff"; }

                if (isRecharging) { rechargeTimer -= delta; rechargeMessageDiv.textContent = `Restaurando Energia Casa... ${rechargeTimer.toFixed(1)}s`; rechargeMessageDiv.style.display = 'block'; if (rechargeTimer <= 0) { isRecharging = false; freezePlayer = false; isPowerOut = false; currentEnergy = MAX_ENERGY; restoreDevicesVisuals(); rechargeMessageDiv.style.display = 'none'; console.log("Recarga Casa Completa! Energia Restaurada."); powerStatusMessageDiv.textContent = `ENERGIA CASA: ${((currentEnergy / MAX_ENERGY) * 100).toFixed(0)}%`; powerStatusMessageDiv.style.color = "#ffccaa"; } } else { rechargeMessageDiv.style.display = 'none'; }

                if (isRechargingFlashlight) { flashlightRechargeMessageDiv.textContent = `Recarregando Lanterna... ${((flashlightEnergy / FLASHLIGHT_MAX_ENERGY) * 100).toFixed(0)}%`; flashlightRechargeMessageDiv.style.display = 'block'; if (!isPowerOut) { flashlightEnergy += FLASHLIGHT_RECHARGE_RATE_PER_SEC * delta; flashlightEnergy = Math.min(FLASHLIGHT_MAX_ENERGY, flashlightEnergy); if (flashlightEnergy >= FLASHLIGHT_MAX_ENERGY) { isRechargingFlashlight = false; freezePlayer = false; flashlightRechargeMessageDiv.style.display = 'none'; console.log("Recarga Lanterna Completa!"); } } else { isRechargingFlashlight = false; freezePlayer = false; flashlightRechargeMessageDiv.style.display = 'none'; console.log("Recarga da lanterna interrompida pela queda de energia."); } } else { flashlightRechargeMessageDiv.style.display = 'none'; }

                if (!freezePlayer && !isTransitioningCamera && !isTransitioningZoom && !isInBookView && !isRecharging && !isRechargingFlashlight && document.pointerLockElement === renderer.domElement) { handlePlayerMovementWithCollision(); }
                else if (document.pointerLockElement !== renderer.domElement && configPanel.style.display === 'none') { velocity.multiplyScalar(damping * 0.8); if (isInGravityZone) { velocity.y -= GRAVITY_STRENGTH; applyGravityAndCollisionCorrection(); } if (velocity.lengthSq() > 0.0001) { let allowedVelocity = checkWallCollisions(velocity); camera.position.add(allowedVelocity); applyGravityAndCollisionCorrection(); } }
                else { velocity.multiplyScalar(damping * 0.5); if (isInGravityZone) { velocity.y -= GRAVITY_STRENGTH; applyGravityAndCollisionCorrection(); } if (velocity.lengthSq() > 0.0001) { let allowedVelocity = checkWallCollisions(velocity); camera.position.add(allowedVelocity); applyGravityAndCollisionCorrection(); } if (velocity.lengthSq() < 0.001) velocity.set(0,0,0); }
                hudSpeed.textContent = `Velocidade: ${velocity.length().toFixed(2)}`;

                if (flashlight && flashlight.target) {
                    camera.getWorldPosition(flashlight.position);
                    camera.getWorldDirection(_vector);
                    flashlight.target.position.copy(flashlight.position).add(_vector.multiplyScalar(1));
                }

                if (physicsBlocksGroup) { blockData.forEach(data => { const block = data.block; block.rotation.x += block.userData.angularVelocity.x; block.rotation.y += block.userData.angularVelocity.y; block.rotation.z += block.userData.angularVelocity.z; if (data.text) { let targetPosition = new THREE.Vector3(); camera.getWorldPosition(targetPosition); let parentWorldMatrixInverse = block.matrixWorld.clone().invert(); targetPosition.applyMatrix4(parentWorldMatrixInverse); data.text.lookAt(targetPosition); } }); }

                isNearBookshelf = false; isNearLampButton = false; isNearComputer = false; isNearBreaker = false; isNearSocket = false;
                const playerPos = camera.position;
                if (!isSitting && !isInBookView && !isZoomedToComputer && !isRecharging && !isRechargingFlashlight) { if (bookshelfGroup && playerPos.distanceTo(bookshelfGroup.getWorldPosition(_vector)) < BOOKSHELF_INTERACTION_RANGE) { isNearBookshelf = true; } if (lampButtonMesh && playerPos.distanceTo(lampButtonMesh.getWorldPosition(_vector)) < LAMP_INTERACTION_RANGE) { isNearLampButton = true; } if (computerMonitorMesh && playerPos.distanceTo(computerMonitorMesh.getWorldPosition(_vector)) < COMPUTER_INTERACTION_RANGE) { isNearComputer = true; } if (circuitBreakerMesh && playerPos.distanceTo(circuitBreakerMesh.getWorldPosition(_vector)) < BREAKER_INTERACTION_RANGE) { isNearBreaker = true;} if (wallSocketMesh && playerPos.distanceTo(wallSocketMesh.getWorldPosition(_vector)) < SOCKET_INTERACTION_RANGE) { isNearSocket = true;} }

                chairInteractionDiv.style.display = 'none'; remoteInteractionMessageDiv.style.display = 'none'; bookshelfInteractionMessageDiv.style.display = 'none'; bookshelfOpenMessageDiv.style.display = 'none'; lampInteractionMessageDiv.style.display = 'none'; computerInteractionMessageDiv.style.display = 'none'; cameraAcquiredMessageDiv.style.display = 'none'; cameraPlacementMessageDiv.style.display = 'none'; computerZoomMessageDiv.style.display = 'none'; monitorViewMessageDiv.style.display = 'none'; breakerInteractionMessageDiv.style.display = 'none'; socketInteractionMessageDiv.style.display = 'none';
                if (isInBookView) {  } else if (isBookshelfInteractionOpen) { bookshelfOpenMessageDiv.style.display = 'block'; } else if (isZoomedToComputer && !isTransitioningZoom) { computerZoomMessageDiv.textContent = `Pressione [${ZOOM_KEY.toUpperCase()}] para Voltar`; computerZoomMessageDiv.style.display = 'block'; } else if (isSitting && !isTransitioningCamera) { chairInteractionDiv.textContent = `Pressione [${SIT_KEY.toUpperCase()}] ou Mova-se para levantar`; chairInteractionDiv.style.display = 'block'; } else if (!freezePlayer) { if (isPowerOut && isNearBreaker) { breakerInteractionMessageDiv.textContent = `[${RECHARGE_KEY.toUpperCase()}] Restaurar Energia Casa`; breakerInteractionMessageDiv.style.display = 'block'; } else if (isNearSocket && !isPowerOut && flashlightEnergy < FLASHLIGHT_MAX_ENERGY) { socketInteractionMessageDiv.textContent = `[${FLASHLIGHT_RECHARGE_KEY.toUpperCase()}] Recarregar Lanterna`; socketInteractionMessageDiv.style.display = 'block'; } else { if (!isPowerOut && numCamerasOwned > 0 && numCamerasPlaced < numCamerasOwned) { cameraPlacementMessageDiv.textContent = `Mire e pressione [${PLACE_CAMERA_KEY.toUpperCase()}] para posicionar Câmera ${numCamerasPlaced + 1}`; cameraPlacementMessageDiv.style.display = 'block'; } if (isNearComputer) { if (!isPowerOut && numCamerasOwned < MAX_CAMERAS) { computerInteractionMessageDiv.textContent = `[${BUY_CAMERA_KEY.toUpperCase()}] Comprar Câmera (${numCamerasOwned}/${MAX_CAMERAS})`; computerInteractionMessageDiv.style.display = 'block'; } else if (numCamerasOwned >= MAX_CAMERAS) { computerInteractionMessageDiv.textContent = `Máximo de câmeras atingido (${MAX_CAMERAS})`; computerInteractionMessageDiv.style.display = 'block';} if (!isPowerOut && numCamerasPlaced > 0) { computerZoomMessageDiv.textContent = `[${ZOOM_KEY.toUpperCase()}] Zoom | [${SWITCH_VIEW_KEY.toUpperCase()}] Trocar Visão`; computerZoomMessageDiv.style.display = 'block'; } } if (isNearBookshelf) { bookshelfInteractionMessageDiv.style.display = 'block'; } if (isNearLampButton) { lampInteractionMessageDiv.textContent = `[${LAMP_TOGGLE_KEY.toUpperCase()}] para ${isLampOn ? 'Desligar' : 'Ligar'} Lâmpada`; lampInteractionMessageDiv.style.display = 'block'; } if (chairMesh && playerPos.distanceTo(chairMesh.getWorldPosition(_vector)) < CHAIR_INTERACTION_RANGE) { chairInteractionDiv.textContent = `[${SIT_KEY.toUpperCase()}] para sentar`; chairInteractionDiv.style.display = 'block'; } if (remoteMesh?.visible && !hasRemoteControl && playerPos.distanceTo(remoteMesh.getWorldPosition(_vector)) < REMOTE_INTERACTION_RANGE) { remoteInteractionMessageDiv.textContent = `[${GRAB_REMOTE_KEY.toUpperCase()}] para pegar o controle`; remoteInteractionMessageDiv.style.display = 'block'; } } }

                bookMeshes.forEach((book, index) => { if (book.material.emissive) { if (isBookshelfInteractionOpen && !isInBookView && index === selectedBookIndex) { book.material.emissive.setHex(0x555555); } else { book.material.emissive.setHex(0x000000); } } });
                videoControlDiv.style.display = hasRemoteControl && !isPowerOut ? 'block' : 'none';
                volumeControlDiv.style.display = hasRemoteControl && !isPowerOut ? 'block' : 'none';
                if (hasRemoteControl && !isPowerOut) { updateVolumeMessage(); }
                if (cubelandiaCubeMesh) cubelandiaCubeMesh.rotation.y += 0.005; if (appleGroup) appleGroup.rotation.y -= 0.003;

                if (!isPowerOut && numCamerasPlaced > 0 && cameraRenderTarget && computerMonitorMesh && computerScreenMaterial) { const activeCamIndex = currentMonitorViewIndex; const activePlacedCam = placedCameraObjects[activeCamIndex]; const activePlacedMesh = placedCameraMeshes[activeCamIndex]; if (activePlacedCam) { if (activePlacedMesh) activePlacedMesh.visible = false; if (computerMonitorMesh) computerMonitorMesh.visible = false; renderer.setRenderTarget(cameraRenderTarget); renderer.clear(); renderer.render(scene, activePlacedCam); renderer.setRenderTarget(null); if (activePlacedMesh) activePlacedMesh.visible = true; if (computerMonitorMesh) computerMonitorMesh.visible = true; computerScreenMaterial.map = cameraRenderTarget.texture; computerScreenMaterial.color.setHex(0xffffff); computerScreenMaterial.needsUpdate = true; } else { computerScreenMaterial.map = null; computerScreenMaterial.color.setHex(0x111122); computerScreenMaterial.needsUpdate = true; } } else if (computerScreenMaterial && !isPowerOut) { computerScreenMaterial.map = null; computerScreenMaterial.color.setHex(0x111122); computerScreenMaterial.needsUpdate = true; } else if (computerScreenMaterial && isPowerOut) { computerScreenMaterial.map = null; computerScreenMaterial.color.setHex(0x000000); computerScreenMaterial.needsUpdate = true; }
            }

            renderer.render(scene, camera);
        }

        function updateGravityZoneAndFloor() { const camPos = camera.position; const onPath = pathMesh && camPos.x >= pathMinBounds.x && camPos.x <= pathMaxBounds.x && camPos.z >= pathMinBounds.z && camPos.z <= pathMaxBounds.z; const inHouse = houseGroup && camPos.x >= houseMinBounds.x && camPos.x <= houseMaxBounds.x && camPos.z >= houseMinBounds.z && camPos.z <= houseMaxBounds.z; if (inHouse) { isInGravityZone = true; worldFloorY = HOUSE_POSITION.y + HOUSE_FLOOR_Y_OFFSET; } else if (onPath) { isInGravityZone = true; worldFloorY = pathMesh.position.y + PATH_THICKNESS / 2; } else { isInGravityZone = false; worldFloorY = -Infinity; } }
        function applyGravityAndCollisionCorrection() { if (!isInGravityZone) return; const playerFeetY = camera.position.y - PLAYER_EYE_HEIGHT; if (playerFeetY <= worldFloorY) { camera.position.y = worldFloorY + PLAYER_EYE_HEIGHT; velocity.y = Math.max(0, velocity.y); } if (houseGroup && camera.position.y > (houseMaxBounds.y - WALL_THICKNESS - 0.1)) { camera.position.y = houseMaxBounds.y - WALL_THICKNESS - 0.1; velocity.y = Math.min(0, velocity.y); } }
        function checkWallCollisions(currentVelocity) { if (collidableMeshes.length === 0 || currentVelocity.lengthSq() === 0) { return currentVelocity; } let finalVelocity = currentVelocity.clone(); const originalPos = camera.position; const capsuleRadius = PLAYER_RADIUS; const capsuleHeight = PLAYER_EYE_HEIGHT; const halfHeight = capsuleHeight / 2; function getPlayerAABB(pos) { _playerBox.setFromCenterAndSize( _vector.set(pos.x, pos.y - halfHeight, pos.z), _vector.set(capsuleRadius * 2, capsuleHeight, capsuleRadius * 2) ); return _playerBox; } let testVelX = _vector.set(currentVelocity.x, 0, 0); if (testVelX.lengthSq() > 0.00001) { let nextPosX = originalPos.clone().add(testVelX); let playerColliderX = getPlayerAABB(nextPosX); for (const mesh of collidableMeshes) { if (!mesh.parent || !mesh.geometry || !mesh.visible) continue; mesh.updateWorldMatrix(true, false); _worldBox.setFromObject(mesh, true); if (playerColliderX.intersectsBox(_worldBox)) { finalVelocity.x = 0; break; } } } let currentTestPosZ = originalPos.clone().add(_vector.set(finalVelocity.x, 0, 0)); let testVelZ = _vector.set(0, 0, currentVelocity.z); if (testVelZ.lengthSq() > 0.00001) { let nextPosZ = currentTestPosZ.clone().add(testVelZ); let playerColliderZ = getPlayerAABB(nextPosZ); for (const mesh of collidableMeshes) { if (!mesh.parent || !mesh.geometry || !mesh.visible) continue; mesh.updateWorldMatrix(true, false); _worldBox.setFromObject(mesh, true); if (playerColliderZ.intersectsBox(_worldBox)) { finalVelocity.z = 0; break; } } } finalVelocity.y = currentVelocity.y; return finalVelocity; }
        function handlePlayerMovementWithCollision() { var moveX = 0, moveZ = 0; if (keys['w'] || keys['arrowup']) moveZ += 1; if (keys['s'] || keys['arrowdown']) moveZ -= 1; if (keys['d'] || keys['arrowright']) moveX -= 1; if (keys['a'] || keys['arrowleft']) moveX += 1; var intendedMovement = new THREE.Vector3(); var forward = new THREE.Vector3(); camera.getWorldDirection(forward); forward.normalize(); var right = new THREE.Vector3(); right.crossVectors(camera.up, forward).normalize(); intendedMovement.add(forward.clone().multiplyScalar(moveZ)); intendedMovement.add(right.clone().multiplyScalar(moveX)); intendedMovement.y = 0; if (intendedMovement.lengthSq() > 0) { intendedMovement.normalize(); intendedMovement.multiplyScalar(acceleration); velocity.add(intendedMovement); } if (isInGravityZone) { velocity.y -= GRAVITY_STRENGTH; } velocity.multiplyScalar(damping); if (velocity.lengthSq() > maxSpeed * maxSpeed) { if (isInGravityZone) { let velY = velocity.y; velocity.y = 0; velocity.setLength(maxSpeed); velocity.y = velY; } else { velocity.setLength(maxSpeed); } } if (velocity.lengthSq() > 0.00001) { let allowedVelocity = checkWallCollisions(velocity); camera.position.add(allowedVelocity); } applyGravityAndCollisionCorrection(); }
        function setupEventListeners() { document.addEventListener('keydown', onKeyDown, false); document.addEventListener('keyup', onKeyUp, false); document.addEventListener('click', onClick, false); renderer.domElement.addEventListener('mousemove', onMouseMove, false); document.addEventListener('pointerlockchange', onPointerLockChange, false); document.addEventListener('pointerlockerror', onPointerLockError, false); window.addEventListener('resize', onWindowResize, false); setupMobileButtons(); console.log("Listeners config."); }
        function setupConfigPanel() { pitchLimitCheckbox.checked = isPitchLimitEnabled; sensitivitySlider.value = mouseSensitivity; sensitivityValueSpan.textContent = mouseSensitivity.toFixed(4); pitchLimitCheckbox.addEventListener('change', () => { isPitchLimitEnabled = pitchLimitCheckbox.checked; }); sensitivitySlider.addEventListener('input', () => { mouseSensitivity = parseFloat(sensitivitySlider.value); sensitivityValueSpan.textContent = mouseSensitivity.toFixed(4); }); closeConfigBtn.addEventListener('click', () => { configPanel.style.display = 'none'; if (gameStarted && !isTransitioning && !isSitting && !document.pointerLockElement && !isBookshelfInteractionOpen && !isInBookView && !isZoomedToComputer && !isRecharging && !isRechargingFlashlight) { renderer.domElement.requestPointerLock(); } }); console.log("Painel config init."); }
        function onKeyDown(event) { const key = event.key.toLowerCase(); keys[key] = true; if (isRechargingFlashlight && (key === 'w' || key === 's' || key === 'a' || key === 'd' || key === 'arrowup' || key === 'arrowdown' || key === 'arrowleft' || key === 'arrowright')) { isRechargingFlashlight = false; freezePlayer = false; flashlightRechargeMessageDiv.style.display = 'none'; console.log("Recarga da lanterna interrompida pelo movimento."); } if (isInBookView){ if(key==='escape'||key===BOOKSHELF_INTERACT_KEY){closeBook();event.preventDefault();return;} return; } if (isZoomedToComputer && key === ZOOM_KEY) { console.log("Iniciando Zoom Out..."); isTransitioningZoom = true; isZoomedToComputer = false; event.preventDefault(); return; } if (isZoomedToComputer && key === 'escape') { console.log("Saindo do Zoom (ESC)..."); isTransitioningZoom = true; isZoomedToComputer = false; event.preventDefault(); return; } if (isZoomedToComputer && key !== FLASHLIGHT_TOGGLE_KEY) return; if ((isRecharging || isRechargingFlashlight) && key !== 'escape') { return; } if (isSitting && !isTransitioningCamera && (key==='w'||key==='s'||key==='a'||key==='d'||key==='arrowup'||key==='arrowdown'||key==='arrowleft'||key==='arrowright')){ toggleSit(); event.preventDefault(); return; } if (isPowerOut && key !== RECHARGE_KEY && key !== FLASHLIGHT_TOGGLE_KEY && key !== FLASHLIGHT_RECHARGE_KEY && key !== 'escape') { console.log("Ação bloqueada: Sem energia."); event.preventDefault(); return; } switch (key) { case FLASHLIGHT_TOGGLE_KEY: toggleFlashlight(); event.preventDefault(); break; case FLASHLIGHT_RECHARGE_KEY: if (isNearSocket && !isPowerOut && !isRecharging && !isRechargingFlashlight && flashlightEnergy < FLASHLIGHT_MAX_ENERGY) { console.log("Iniciando recarga da lanterna..."); isRechargingFlashlight = true; freezePlayer = true; socketInteractionMessageDiv.style.display = 'none'; flashlightRechargeMessageDiv.textContent = `Recarregando Lanterna... ${((flashlightEnergy / FLASHLIGHT_MAX_ENERGY) * 100).toFixed(0)}%`; flashlightRechargeMessageDiv.style.display = 'block'; } else if (isNearSocket && isPowerOut) { console.log("Não é possível recarregar lanterna: Energia da casa desligada."); } else if (isNearSocket && flashlightEnergy >= FLASHLIGHT_MAX_ENERGY) { console.log("Lanterna já está com carga máxima."); } event.preventDefault(); break; case RECHARGE_KEY: if (isPowerOut && isNearBreaker && !isRecharging && !isRechargingFlashlight) { console.log("Iniciando recarga de energia da casa..."); isRecharging = true; rechargeTimer = RECHARGE_DURATION; freezePlayer = true; breakerInteractionMessageDiv.style.display = 'none'; rechargeMessageDiv.textContent = `Restaurando Energia Casa... ${rechargeTimer.toFixed(1)}s`; rechargeMessageDiv.style.display = 'block'; } event.preventDefault(); break; case SIT_KEY: if (!isPowerOut && !isTransitioningCamera && chairMesh && !isSitting) { if(camera.position.distanceTo(chairMesh.getWorldPosition(_vector)) < CHAIR_INTERACTION_RANGE){ toggleSit(); }} else if (isSitting && !isTransitioningCamera) { toggleSit();} event.preventDefault(); break; case GRAB_REMOTE_KEY: if (!isPowerOut && !isSitting && !hasRemoteControl && remoteMesh?.visible) { grabRemote(); } event.preventDefault(); break; case VIDEO_PAUSE_KEY: if (!isPowerOut && hasRemoteControl && saganVideoElement) { saganVideoElement.pause(); if (backgroundMusic?.isPlaying) { backgroundMusic.pause(); console.log("MP3 pausado (P)."); } console.log("Vídeo pausado (P)."); } event.preventDefault(); break; case VIDEO_START_KEY: if (!isPowerOut && hasRemoteControl && saganVideoElement) { tryResumeAudioContext(listener.context,()=>{saganVideoElement.muted = true; saganVideoElement.volume = 0; saganVideoElement.play().then(()=>{console.log("Vídeo (mudo) iniciado (T)."); if (backgroundMusic?.buffer && !backgroundMusic.isPlaying) { backgroundMusic.play(); console.log("MP3 iniciado (T)."); } }).catch(e=>console.warn("Play vídeo falhou:", e)); }); } event.preventDefault(); break; case VOLUME_UP_KEY: if (!isPowerOut && hasRemoteControl && backgroundMusic?.buffer) { let v=backgroundMusic.getVolume(); backgroundMusic.setVolume(Math.min(1.0, v + VOLUME_STEP)); updateVolumeMessage(); } event.preventDefault(); break; case VOLUME_DOWN_KEY: if (!isPowerOut && hasRemoteControl && backgroundMusic?.buffer) { let v=backgroundMusic.getVolume(); backgroundMusic.setVolume(Math.max(0.0, v - VOLUME_STEP)); updateVolumeMessage(); } event.preventDefault(); break; case BOOKSHELF_INTERACT_KEY: if (isNearBookshelf && !isSitting && !isTransitioningCamera) { isBookshelfInteractionOpen=!isBookshelfInteractionOpen; selectedBookIndex=-1; if (isBookshelfInteractionOpen) { console.log("Estante aberta."); } else { console.log("Estante fechada."); closeBook(); } } event.preventDefault(); break; case BOOK_SELECT_KEYS[0]: case BOOK_SELECT_KEYS[1]: case BOOK_SELECT_KEYS[2]: if (isBookshelfInteractionOpen && !isInBookView) { const bookIndex=BOOK_SELECT_KEYS.indexOf(key); if (bookIndex !== -1) { displayBookContent(bookIndex); } } break; case LAMP_TOGGLE_KEY: if (isNearLampButton && !isSitting && !isTransitioningCamera) { toggleLamp(); } event.preventDefault(); break; case BUY_CAMERA_KEY: if (!isPowerOut && isNearComputer && numCamerasOwned < MAX_CAMERAS && !isSitting && !isTransitioningCamera && !isInBookView) { numCamerasOwned++; console.log(`Comprando câmera ${numCamerasOwned}/${MAX_CAMERAS}...`); computerInteractionMessageDiv.style.display = 'none'; cameraAcquiredMessageDiv.textContent = `Câmera ${numCamerasOwned} Adquirida!`; cameraAcquiredMessageDiv.style.display = 'block'; setTimeout(() => { cameraAcquiredMessageDiv.style.display = 'none'; }, 2000); } else if (isNearComputer && numCamerasOwned >= MAX_CAMERAS) { cameraAcquiredMessageDiv.textContent = `Máximo de ${MAX_CAMERAS} câmeras atingido!`; cameraAcquiredMessageDiv.style.display = 'block'; setTimeout(() => { cameraAcquiredMessageDiv.style.display = 'none'; }, 2000); } event.preventDefault(); break; case PLACE_CAMERA_KEY: if (!isPowerOut && numCamerasPlaced < numCamerasOwned && !isSitting && !isTransitioningCamera && !isInBookView && !isZoomedToComputer) { _placementRay.setFromCamera(new THREE.Vector2(0, 0), camera); const targets = collidableMeshes.filter(m => !placedCameraMeshes.includes(m)); const intersects = _placementRay.intersectObjects(targets, true); if (intersects.length > 0) { const intersection = intersects[0]; if (intersection.distance < CAMERA_PLACE_MAX_DISTANCE) { const placementIndex = numCamerasPlaced; const offset = intersection.face.normal.clone().multiplyScalar(0.05); const placementPosition = intersection.point.clone().add(offset); const lookAtTarget = new THREE.Vector3(HOUSE_POSITION.x, PLAYER_EYE_HEIGHT, HOUSE_POSITION.z); const cameraColor = CAMERA_COLORS[placementIndex % CAMERA_COLORS.length]; console.log(`Posicionando câmera ${placementIndex + 1} em:`, placementPosition, "Normal:", intersection.face.normal); if (!placedCameraObjects[placementIndex]) { placedCameraObjects[placementIndex] = new THREE.PerspectiveCamera(50, CAMERA_RENDER_TARGET_WIDTH / CAMERA_RENDER_TARGET_HEIGHT, 0.2, 50); } placedCameraObjects[placementIndex].position.copy(placementPosition); placedCameraObjects[placementIndex].lookAt(lookAtTarget); placedCameraObjects[placementIndex].userData.lookAtTarget = lookAtTarget.clone(); if (placedCameraMeshes[placementIndex]) { const oldMesh = placedCameraMeshes[placementIndex]; const collidableIndex = collidableMeshes.indexOf(oldMesh); if(collidableIndex > -1) collidableMeshes.splice(collidableIndex, 1); if(oldMesh.parent) oldMesh.parent.remove(oldMesh); } const newCameraMesh = createPlacedCameraVisual(placementPosition, lookAtTarget, cameraColor); scene.add(newCameraMesh); collidableMeshes.push(newCameraMesh); placedCameraMeshes[placementIndex] = newCameraMesh; numCamerasPlaced++; currentMonitorViewIndex = placementIndex; cameraPlacementMessageDiv.style.display = 'none'; console.log(`Câmera ${numCamerasPlaced} posicionada via Raycast.`); } else { console.log("Muito longe para posicionar a câmera."); } } else { console.log("Nenhuma superfície válida encontrada na mira."); } } else if (numCamerasPlaced >= numCamerasOwned && numCamerasOwned > 0) { console.log("Todas as câmeras compradas já foram posicionadas."); cameraPlacementMessageDiv.textContent = "Todas as câmeras compradas já foram posicionadas!"; cameraPlacementMessageDiv.style.display = 'block'; setTimeout(() => { cameraPlacementMessageDiv.style.display = 'none'; }, 2000); } event.preventDefault(); break; case SWITCH_VIEW_KEY: if (!isPowerOut && numCamerasPlaced > 0 && !isSitting && !isInBookView && !isZoomedToComputer) { currentMonitorViewIndex = (currentMonitorViewIndex + 1) % numCamerasPlaced; console.log(`Monitor exibindo Câmera ${currentMonitorViewIndex + 1}`); monitorViewMessageDiv.textContent = `Monitor: Câmera ${currentMonitorViewIndex + 1}`; monitorViewMessageDiv.style.display = 'block'; setTimeout(() => { monitorViewMessageDiv.style.display = 'none'; }, 1500); } event.preventDefault(); break; case ZOOM_KEY: if (!isPowerOut && isNearComputer && numCamerasPlaced > 0 && !isSitting && !isInBookView && !isZoomedToComputer && !isTransitioningZoom) { console.log("Iniciando Zoom In..."); preZoomPos.copy(camera.position); preZoomQuat.copy(camera.quaternion); originalFov = camera.fov; const monitorCenter = computerMonitorMesh.getWorldPosition(_vector.clone()); const monitorWorldQuaternion = computerMonitorMesh.getWorldQuaternion(_worldQuaternion); const forwardVector = new THREE.Vector3(0, 0, 1).applyQuaternion(monitorWorldQuaternion); targetZoomPos.copy(monitorCenter).add(forwardVector.multiplyScalar(0.4)); targetZoomPos.y = monitorCenter.y; targetZoomLookAt.copy(monitorCenter); freezePlayer = true; isZoomedToComputer = true; isTransitioningZoom = true; } event.preventDefault(); break; case 'escape': if (isRecharging || isRechargingFlashlight) { document.exitPointerLock(); } else if (document.pointerLockElement === renderer.domElement) { document.exitPointerLock(); } else if (configPanel.style.display === 'block'){ configPanel.style.display = 'none'; } else if (gameStarted && !isTransitioning && !isSitting && !isBookshelfInteractionOpen && !isZoomedToComputer) { configPanel.style.display = 'block'; } event.preventDefault(); break; } }
        function onKeyUp(event) { keys[event.key.toLowerCase()] = false; }
        function onClick(event) { if (event.target.closest('.mobile-buttons') || event.target.closest('#configPanel') || event.target.id === 'closeBookBtn') { return; } if (!gameStarted && menuGroup && mainFont) { const rect = renderer.domElement.getBoundingClientRect(); mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1; mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1; raycaster.setFromCamera(mouse, camera); const objectsToCheck = []; if (playTextMesh) objectsToCheck.push(playTextMesh); if (configTextMesh) objectsToCheck.push(configTextMesh); const intersects = raycaster.intersectObjects(objectsToCheck); if (intersects.length > 0) { const clickedObject = intersects[0].object; if (clickedObject === playTextMesh) { console.log("Clicou em Explorar"); tryResumeAudioContext(listener.context, startGame); } else if (clickedObject === configTextMesh) { console.log("Clicou em Config"); configPanel.style.display = 'block'; } return; } } else if (gameStarted && document.pointerLockElement !== renderer.domElement && !isTransitioning && !isSitting && configPanel.style.display === 'none' && !isBookshelfInteractionOpen && !isInBookView && !isZoomedToComputer && !isRecharging && !isRechargingFlashlight) { console.log("Clicou para reativar o Pointer Lock."); renderer.domElement.requestPointerLock(); tryResumeAudioContext(listener.context); } }
        function onMouseMove(event) { if (document.pointerLockElement === renderer.domElement && !freezePlayer) { const sensitivity = mouseSensitivity; const movementX = event.movementX || 0; const movementY = event.movementY || 0; camera.rotation.y -= movementX * sensitivity; camera.rotation.x -= movementY * sensitivity; if (isPitchLimitEnabled) { const piOver2 = Math.PI / 2; camera.rotation.x = Math.max(-piOver2 * 0.99, Math.min(piOver2 * 0.99, camera.rotation.x)); } } }
        function onPointerLockChange() { if (document.pointerLockElement === renderer.domElement) { console.log('Pointer Lock Ativado.'); pointerLockDiv.style.display = 'none'; document.body.style.cursor = 'none'; configPanel.style.display = 'none'; if(!isSitting && !isInBookView && !isZoomedToComputer && !isRecharging && !isRechargingFlashlight) { hudCrosshair.style.display = 'block'; hudSpeed.style.display = 'block'; } } else { console.log('Pointer Lock Desativado.'); document.body.style.cursor = 'default'; hudCrosshair.style.display = 'none'; hudSpeed.style.display = 'none'; if (gameStarted && !isTransitioning && !isSitting && configPanel.style.display === 'none' && !isInBookView && !isBookshelfInteractionOpen && !isZoomedToComputer && !isRecharging && !isRechargingFlashlight) { pointerLockDiv.innerHTML = "Cursor Liberado<br>ESC para Config | Clique para retomar"; pointerLockDiv.style.display = 'block'; } else { pointerLockDiv.style.display = 'none'; } if (isTransitioningZoom && !isZoomedToComputer) { isTransitioningZoom = false; camera.position.copy(preZoomPos); camera.quaternion.copy(preZoomQuat); camera.fov = CAMERA_FOV_NORMAL; camera.updateProjectionMatrix(); freezePlayer = false; console.log("Zoom Out cancelado por perda de foco."); } else if (isZoomedToComputer) { isTransitioningZoom = true; isZoomedToComputer = false; console.log("Saindo do zoom por perda de foco."); } } }
        function onPointerLockError(event) { console.error('Erro Pointer Lock:', event); pointerLockDiv.innerText = "Erro ao travar cursor."; pointerLockDiv.style.display = 'block'; document.body.style.cursor = 'default'; hudCrosshair.style.display = 'none'; hudSpeed.style.display = 'none'; }
        function onWindowResize() { if (!camera || !renderer) return; camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); if (cameraRenderTarget) { cameraRenderTarget.setSize(CAMERA_RENDER_TARGET_WIDTH, CAMERA_RENDER_TARGET_HEIGHT); } console.log("Janela redimensionada."); }
        function setupMobileButtons() { const btnUp = document.getElementById('btn-up'); const btnDown = document.getElementById('btn-down'); const btnLeft = document.getElementById('btn-left'); const btnRight = document.getElementById('btn-right'); if(btnUp && btnDown && btnLeft && btnRight) { function addButtonControl(button, key) { button.addEventListener('touchstart', (e) => { e.preventDefault(); keys[key] = true; }, { passive: false }); button.addEventListener('touchend', (e) => { e.preventDefault(); keys[key] = false; }, { passive: false }); button.addEventListener('contextmenu', (e) => { e.preventDefault(); }, false); button.addEventListener('mousedown', (e) => { e.preventDefault(); keys[key] = true; }); button.addEventListener('mouseup', (e) => { e.preventDefault(); keys[key] = false; }); button.addEventListener('mouseleave', (e) => { if(keys[key]) { keys[key] = false;} }); } addButtonControl(btnUp, 'w'); addButtonControl(btnDown, 's'); addButtonControl(btnLeft, 'a'); addButtonControl(btnRight, 'd'); } else { console.log("Botões mobile não encontrados."); } }
        function tryResumeAudioContext(context, callbackOnResume) { if (!context) return; if (context.state === 'suspended') { context.resume().then(() => { console.log("AudioContext resumido."); if (callbackOnResume) callbackOnResume(); }).catch(e => console.error("Erro resumir AudioContext:", e)); } else if (context.state === 'running'){ if (callbackOnResume) callbackOnResume(); } else { console.warn("AudioContext state:", context.state); } }

        init();
    </script>

</body>
</html>
